webpackHotUpdate_N_E("pages/index",{

/***/ "./components/Template/Header/Header.tsx":
/*!***********************************************!*\
  !*** ./components/Template/Header/Header.tsx ***!
  \***********************************************/
/*! exports provided: Header */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(module) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Header\", function() { return Header; });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _Text__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../Text */ \"./components/Text/index.ts\");\n/* harmony import */ var _styles__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./styles */ \"./components/Template/Header/styles.ts\");\n/* harmony import */ var _Button__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../Button */ \"./components/Button/index.ts\");\n/* harmony import */ var popcorntime__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! popcorntime */ \"./node_modules/popcorntime/src/index.js\");\n/* harmony import */ var popcorntime__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(popcorntime__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var imdb_api__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! imdb-api */ \"./node_modules/imdb-api/lib/imdb.js\");\n/* harmony import */ var imdb_api__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(imdb_api__WEBPACK_IMPORTED_MODULE_5__);\nvar _this = undefined,\n    _jsxFileName = \"/home/daianebarizon/Repositories/popcorn2/popcorn-time-site/components/Template/Header/Header.tsx\";\n\nvar __jsx = react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement;\n\n\n\n\n\n\nvar Header = function Header(props) {\n  var options = {\n    page: 1,\n    sortby: 'seeds',\n    genre: 'all',\n    q: '' // It is useful to do a search or you can leave it empty\n\n  };\n  var data = Object(popcorntime__WEBPACK_IMPORTED_MODULE_4__[\"movies\"])(options);\n  console.log('data', data);\n  Object(popcorntime__WEBPACK_IMPORTED_MODULE_4__[\"movies\"])(options).then(function (data) {\n    return console.log('api', data);\n  });\n  var apiImdb = imdb_api__WEBPACK_IMPORTED_MODULE_5___default.a.get({\n    name: 'The Toxic Avenger'\n  }, {\n    apiKey: 'foo',\n    timeout: 30000\n  }).then(console.log)[\"catch\"](console.log);\n  console.log('apiImdb', apiImdb);\n  return __jsx(_styles__WEBPACK_IMPORTED_MODULE_2__[\"HeaderWrapper\"], {\n    __self: _this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 27,\n      columnNumber: 9\n    }\n  }, __jsx(_Text__WEBPACK_IMPORTED_MODULE_1__[\"Text\"], {\n    as: \"h1\",\n    fontWeight: \"light\",\n    fontSize: \"45px\",\n    m: \"0\",\n    __self: _this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 28,\n      columnNumber: 13\n    }\n  }, \"Watch Movies and TV Shows Instantly\"), __jsx(_Text__WEBPACK_IMPORTED_MODULE_1__[\"Text\"], {\n    as: \"h2\",\n    fontWeight: \"light\",\n    fontSize: \"30px\",\n    color: \"green\",\n    m: \"0\",\n    __self: _this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 31,\n      columnNumber: 13\n    }\n  }, \"Currently in Beta, but go ahead and try it!\"), __jsx(_Button__WEBPACK_IMPORTED_MODULE_3__[\"Button\"], {\n    mt: \"20px\",\n    onClick: function onClick() {\n      return alert('clique');\n    },\n    __self: _this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 40,\n      columnNumber: 13\n    }\n  }, __jsx(_Text__WEBPACK_IMPORTED_MODULE_1__[\"Text\"], {\n    color: \"white\",\n    fontSize: \"25px\",\n    fontWeight: \"medium\",\n    __self: _this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 41,\n      columnNumber: 17\n    }\n  }, \"Download Popcorn Time 4.4\")), __jsx(_Text__WEBPACK_IMPORTED_MODULE_1__[\"Text\"], {\n    as: \"small\",\n    fontWeight: \"light\",\n    fontSize: \"13px\",\n    color: \"red\",\n    mt: \"13px\",\n    __self: _this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 45,\n      columnNumber: 13\n    }\n  }, \"For Windows 7 and above Other operating systems and platforms\"));\n};\n_c = Header;\n\nvar _c;\n\n$RefreshReg$(_c, \"Header\");\n\n;\n    var _a, _b;\n    // Legacy CSS implementations will `eval` browser code in a Node.js context\n    // to extract CSS. For backwards compatibility, we need to check we're in a\n    // browser context before continuing.\n    if (typeof self !== 'undefined' &&\n        // AMP / No-JS mode does not inject these helpers:\n        '$RefreshHelpers$' in self) {\n        var currentExports = module.__proto__.exports;\n        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n        // This cannot happen in MainTemplate because the exports mismatch between\n        // templating and execution.\n        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);\n        // A module can be accepted automatically based on its exports, e.g. when\n        // it is a Refresh Boundary.\n        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n            // Save the previous exports on update so we can compare the boundary\n            // signatures.\n            module.hot.dispose(function (data) {\n                data.prevExports = currentExports;\n            });\n            // Unconditionally accept an update to this module, we'll check if it's\n            // still a Refresh Boundary later.\n            module.hot.accept();\n            // This field is set when the previous version of this module was a\n            // Refresh Boundary, letting us know we need to check for invalidation or\n            // enqueue an update.\n            if (prevExports !== null) {\n                // A boundary can become ineligible if its exports are incompatible\n                // with the previous exports.\n                //\n                // For example, if you add/remove/change exports, we'll want to\n                // re-execute the importing modules, and force those components to\n                // re-render. Similarly, if you convert a class component to a\n                // function, we want to invalidate the boundary.\n                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                    module.hot.invalidate();\n                }\n                else {\n                    self.$RefreshHelpers$.scheduleUpdate();\n                }\n            }\n        }\n        else {\n            // Since we just executed the code for the module, it's possible that the\n            // new exports made it ineligible for being a boundary.\n            // We only care about the case when we were _previously_ a boundary,\n            // because we already accepted this update (accidental side effect).\n            var isNoLongerABoundary = prevExports !== null;\n            if (isNoLongerABoundary) {\n                module.hot.invalidate();\n            }\n        }\n    }\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../node_modules/webpack/buildin/harmony-module.js */ \"./node_modules/webpack/buildin/harmony-module.js\")(module)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vY29tcG9uZW50cy9UZW1wbGF0ZS9IZWFkZXIvSGVhZGVyLnRzeD8zMzdmIl0sIm5hbWVzIjpbIkhlYWRlciIsInByb3BzIiwib3B0aW9ucyIsInBhZ2UiLCJzb3J0YnkiLCJnZW5yZSIsInEiLCJkYXRhIiwibW92aWVzIiwiY29uc29sZSIsImxvZyIsInRoZW4iLCJhcGlJbWRiIiwiaW1kYiIsImdldCIsIm5hbWUiLCJhcGlLZXkiLCJ0aW1lb3V0IiwiYWxlcnQiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlPLElBQU1BLE1BQU0sR0FBSSxTQUFWQSxNQUFVLENBQUNDLEtBQUQsRUFBa0I7QUFDckMsTUFBTUMsT0FBTyxHQUFHO0FBQ1pDLFFBQUksRUFBRSxDQURNO0FBRVpDLFVBQU0sRUFBRSxPQUZJO0FBR1pDLFNBQUssRUFBRSxLQUhLO0FBSVpDLEtBQUMsRUFBRSxFQUpTLENBSU47O0FBSk0sR0FBaEI7QUFNQSxNQUFNQyxJQUFJLEdBQUlDLDBEQUFNLENBQUNOLE9BQUQsQ0FBcEI7QUFDQU8sU0FBTyxDQUFDQyxHQUFSLENBQVksTUFBWixFQUFvQkgsSUFBcEI7QUFFQUMsNERBQU0sQ0FBQ04sT0FBRCxDQUFOLENBQWdCUyxJQUFoQixDQUFxQixVQUFDSixJQUFEO0FBQUEsV0FBVUUsT0FBTyxDQUFDQyxHQUFSLENBQVksS0FBWixFQUFtQkgsSUFBbkIsQ0FBVjtBQUFBLEdBQXJCO0FBRUEsTUFBTUssT0FBTyxHQUFHQywrQ0FBSSxDQUFDQyxHQUFMLENBQVM7QUFBQ0MsUUFBSSxFQUFFO0FBQVAsR0FBVCxFQUFzQztBQUFDQyxVQUFNLEVBQUUsS0FBVDtBQUFnQkMsV0FBTyxFQUFFO0FBQXpCLEdBQXRDLEVBQXVFTixJQUF2RSxDQUE0RUYsT0FBTyxDQUFDQyxHQUFwRixXQUErRkQsT0FBTyxDQUFDQyxHQUF2RyxDQUFoQjtBQUVBRCxTQUFPLENBQUNDLEdBQVIsQ0FBWSxTQUFaLEVBQXVCRSxPQUF2QjtBQUVBLFNBQ0ksTUFBQyxxREFBRDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEtBQ0ksTUFBQywwQ0FBRDtBQUFNLE1BQUUsRUFBQyxJQUFUO0FBQWMsY0FBVSxFQUFDLE9BQXpCO0FBQWlDLFlBQVEsRUFBQyxNQUExQztBQUFpRCxLQUFDLEVBQUMsR0FBbkQ7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSwyQ0FESixFQUlJLE1BQUMsMENBQUQ7QUFDSSxNQUFFLEVBQUMsSUFEUDtBQUVJLGNBQVUsRUFBQyxPQUZmO0FBR0ksWUFBUSxFQUFDLE1BSGI7QUFJSSxTQUFLLEVBQUMsT0FKVjtBQUtJLEtBQUMsRUFBQyxHQUxOO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsbURBSkosRUFhSSxNQUFDLDhDQUFEO0FBQVEsTUFBRSxFQUFDLE1BQVg7QUFBa0IsV0FBTyxFQUFFO0FBQUEsYUFBTU0sS0FBSyxDQUFDLFFBQUQsQ0FBWDtBQUFBLEtBQTNCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsS0FDSSxNQUFDLDBDQUFEO0FBQU0sU0FBSyxFQUFDLE9BQVo7QUFBb0IsWUFBUSxFQUFDLE1BQTdCO0FBQW9DLGNBQVUsRUFBQyxRQUEvQztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLGlDQURKLENBYkosRUFrQkksTUFBQywwQ0FBRDtBQUNJLE1BQUUsRUFBQyxPQURQO0FBRUksY0FBVSxFQUFDLE9BRmY7QUFHSSxZQUFRLEVBQUMsTUFIYjtBQUlJLFNBQUssRUFBQyxLQUpWO0FBS0ksTUFBRSxFQUFDLE1BTFA7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxxRUFsQkosQ0FESjtBQThCSCxDQTlDTTtLQUFNbEIsTSIsImZpbGUiOiIuL2NvbXBvbmVudHMvVGVtcGxhdGUvSGVhZGVyL0hlYWRlci50c3guanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgeyBUZXh0IH0gZnJvbSAnLi4vLi4vVGV4dCc7XHJcbmltcG9ydCB7IEhlYWRlcldyYXBwZXIgfSBmcm9tICcuL3N0eWxlcyc7XHJcbmltcG9ydCB7IEJ1dHRvbiB9IGZyb20gJy4uLy4uL0J1dHRvbic7XHJcbmltcG9ydCB7IG1vdmllcyB9IGZyb20gJ3BvcGNvcm50aW1lJztcclxuaW1wb3J0IGltZGIgZnJvbSAnaW1kYi1hcGknXHJcblxyXG5pbnRlcmZhY2UgUHJvcHMge31cclxuXHJcbmV4cG9ydCBjb25zdCBIZWFkZXIgPSAgKHByb3BzOiBQcm9wcykgPT4ge1xyXG4gICAgY29uc3Qgb3B0aW9ucyA9IHtcclxuICAgICAgICBwYWdlOiAxLFxyXG4gICAgICAgIHNvcnRieTogJ3NlZWRzJyxcclxuICAgICAgICBnZW5yZTogJ2FsbCcsXHJcbiAgICAgICAgcTogJycgLy8gSXQgaXMgdXNlZnVsIHRvIGRvIGEgc2VhcmNoIG9yIHlvdSBjYW4gbGVhdmUgaXQgZW1wdHlcclxuICAgICAgfTtcclxuICAgIGNvbnN0IGRhdGEgPSAgbW92aWVzKG9wdGlvbnMpO1xyXG4gICAgY29uc29sZS5sb2coJ2RhdGEnLCBkYXRhKVxyXG5cclxuICAgIG1vdmllcyhvcHRpb25zKS50aGVuKChkYXRhKSA9PiBjb25zb2xlLmxvZygnYXBpJywgZGF0YSkpO1xyXG5cclxuICAgIGNvbnN0IGFwaUltZGIgPSBpbWRiLmdldCh7bmFtZTogJ1RoZSBUb3hpYyBBdmVuZ2VyJ30sIHthcGlLZXk6ICdmb28nLCB0aW1lb3V0OiAzMDAwMH0pLnRoZW4oY29uc29sZS5sb2cpLmNhdGNoKGNvbnNvbGUubG9nKTtcclxuIFxyXG4gICAgY29uc29sZS5sb2coJ2FwaUltZGInLCBhcGlJbWRiKVxyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPEhlYWRlcldyYXBwZXI+XHJcbiAgICAgICAgICAgIDxUZXh0IGFzPSdoMScgZm9udFdlaWdodD0nbGlnaHQnIGZvbnRTaXplPSc0NXB4JyBtPScwJz5cclxuICAgICAgICAgICAgICAgIFdhdGNoIE1vdmllcyBhbmQgVFYgU2hvd3MgSW5zdGFudGx5XHJcbiAgICAgICAgICAgIDwvVGV4dD5cclxuICAgICAgICAgICAgPFRleHRcclxuICAgICAgICAgICAgICAgIGFzPSdoMidcclxuICAgICAgICAgICAgICAgIGZvbnRXZWlnaHQ9J2xpZ2h0J1xyXG4gICAgICAgICAgICAgICAgZm9udFNpemU9JzMwcHgnXHJcbiAgICAgICAgICAgICAgICBjb2xvcj0nZ3JlZW4nXHJcbiAgICAgICAgICAgICAgICBtPScwJ1xyXG4gICAgICAgICAgICA+XHJcbiAgICAgICAgICAgICAgICBDdXJyZW50bHkgaW4gQmV0YSwgYnV0IGdvIGFoZWFkIGFuZCB0cnkgaXQhXHJcbiAgICAgICAgICAgIDwvVGV4dD5cclxuICAgICAgICAgICAgPEJ1dHRvbiBtdD0nMjBweCcgb25DbGljaz17KCkgPT4gYWxlcnQoJ2NsaXF1ZScpfT5cclxuICAgICAgICAgICAgICAgIDxUZXh0IGNvbG9yPSd3aGl0ZScgZm9udFNpemU9JzI1cHgnIGZvbnRXZWlnaHQ9J21lZGl1bSc+XHJcbiAgICAgICAgICAgICAgICAgICAgRG93bmxvYWQgUG9wY29ybiBUaW1lIDQuNFxyXG4gICAgICAgICAgICAgICAgPC9UZXh0PlxyXG4gICAgICAgICAgICA8L0J1dHRvbj5cclxuICAgICAgICAgICAgPFRleHRcclxuICAgICAgICAgICAgICAgIGFzPSdzbWFsbCdcclxuICAgICAgICAgICAgICAgIGZvbnRXZWlnaHQ9J2xpZ2h0J1xyXG4gICAgICAgICAgICAgICAgZm9udFNpemU9JzEzcHgnXHJcbiAgICAgICAgICAgICAgICBjb2xvcj0ncmVkJ1xyXG4gICAgICAgICAgICAgICAgbXQ9JzEzcHgnXHJcbiAgICAgICAgICAgID5cclxuICAgICAgICAgICAgICAgIEZvciBXaW5kb3dzIDcgYW5kIGFib3ZlIE90aGVyIG9wZXJhdGluZyBzeXN0ZW1zIGFuZCBwbGF0Zm9ybXNcclxuICAgICAgICAgICAgPC9UZXh0PlxyXG4gICAgICAgIDwvSGVhZGVyV3JhcHBlcj5cclxuICAgICk7XHJcbn07XHJcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./components/Template/Header/Header.tsx\n");

/***/ }),

/***/ "./node_modules/@ungap/url-search-params/esm/index.js":
/*!************************************************************!*\
  !*** ./node_modules/@ungap/url-search-params/esm/index.js ***!
  \************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/*! (c) Andrea Giammarchi - ISC */\nvar self = {};\ntry {\n  (function (URLSearchParams, plus) {\n    if (\n      new URLSearchParams('q=%2B').get('q') !== plus ||\n      new URLSearchParams({q: plus}).get('q') !== plus ||\n      new URLSearchParams([['q', plus]]).get('q') !== plus ||\n      new URLSearchParams('q=\\n').toString() !== 'q=%0A' ||\n      new URLSearchParams({q: ' &'}).toString() !== 'q=+%26' ||\n      new URLSearchParams({q: '%zx'}).toString() !== 'q=%25zx'\n    )\n      throw URLSearchParams;\n    self.URLSearchParams = URLSearchParams;\n  }(URLSearchParams, '+'));\n} catch(URLSearchParams) {\n  (function (Object, String, isArray) {'use strict';\n    var create = Object.create;\n    var defineProperty = Object.defineProperty;\n    var find = /[!'\\(\\)~]|%20|%00/g;\n    var findPercentSign = /%(?![0-9a-fA-F]{2})/g;\n    var plus = /\\+/g;\n    var replace = {\n      '!': '%21',\n      \"'\": '%27',\n      '(': '%28',\n      ')': '%29',\n      '~': '%7E',\n      '%20': '+',\n      '%00': '\\x00'\n    };\n    var proto = {\n      append: function (key, value) {\n        appendTo(this._ungap, key, value);\n      },\n      delete: function (key) {\n        delete this._ungap[key];\n      },\n      get: function (key) {\n        return this.has(key) ? this._ungap[key][0] : null;\n      },\n      getAll: function (key) {\n        return this.has(key) ? this._ungap[key].slice(0) : [];\n      },\n      has: function (key) {\n        return key in this._ungap;\n      },\n      set: function (key, value) {\n        this._ungap[key] = [String(value)];\n      },\n      forEach: function (callback, thisArg) {\n        var self = this;\n        for (var key in self._ungap)\n          self._ungap[key].forEach(invoke, key);\n        function invoke(value) {\n          callback.call(thisArg, value, String(key), self);\n        }\n      },\n      toJSON: function () {\n        return {};\n      },\n      toString: function () {\n        var query = [];\n        for (var key in this._ungap) {\n          var encoded = encode(key);\n          for (var\n            i = 0,\n            value = this._ungap[key];\n            i < value.length; i++\n          ) {\n            query.push(encoded + '=' + encode(value[i]));\n          }\n        }\n        return query.join('&');\n      }\n    };\n    for (var key in proto)\n      defineProperty(URLSearchParams.prototype, key, {\n        configurable: true,\n        writable: true,\n        value: proto[key]\n      });\n    self.URLSearchParams = URLSearchParams;\n    function URLSearchParams(query) {\n      var dict = create(null);\n      defineProperty(this, '_ungap', {value: dict});\n      switch (true) {\n        case !query:\n          break;\n        case typeof query === 'string':\n          if (query.charAt(0) === '?') {\n            query = query.slice(1);\n          }\n          for (var\n            pairs = query.split('&'),\n            i = 0,\n            length = pairs.length; i < length; i++\n          ) {\n            var value = pairs[i];\n            var index = value.indexOf('=');\n            if (-1 < index) {\n              appendTo(\n                dict,\n                decode(value.slice(0, index)),\n                decode(value.slice(index + 1))\n              );\n            } else if (value.length){\n              appendTo(\n                dict,\n                decode(value),\n                ''\n              );\n            }\n          }\n          break;\n        case isArray(query):\n          for (var\n            i = 0,\n            length = query.length; i < length; i++\n          ) {\n            var value = query[i];\n            appendTo(dict, value[0], value[1]);\n          }\n          break;\n        case 'forEach' in query:\n          query.forEach(addEach, dict);\n          break;\n        default:\n          for (var key in query)\n            appendTo(dict, key, query[key]);\n      }\n    }\n\n    function addEach(value, key) {\n      appendTo(this, key, value);\n    }\n\n    function appendTo(dict, key, value) {\n      var res = isArray(value) ? value.join(',') : value;\n      if (key in dict)\n        dict[key].push(res);\n      else\n        dict[key] = [res];\n    }\n\n    function decode(str) {\n      return decodeURIComponent(str.replace(findPercentSign, '%25').replace(plus, ' '));\n    }\n\n    function encode(str) {\n      return encodeURIComponent(str).replace(find, replacer);\n    }\n\n    function replacer(match) {\n      return replace[match];\n    }\n\n  }(Object, String, Array.isArray));\n}\n\n(function (URLSearchParamsProto) {\n\n  var iterable = false;\n  try { iterable = !!Symbol.iterator; } catch (o_O) {}\n\n  /* istanbul ignore else */\n  if (!('forEach' in URLSearchParamsProto)) {\n    URLSearchParamsProto.forEach = function forEach(callback, thisArg) {\n      var self = this;\n      var names = Object.create(null);\n      this.toString()\n          .replace(/=[\\s\\S]*?(?:&|$)/g, '=')\n          .split('=')\n          .forEach(function (name) {\n            if (!name.length || name in names)\n              return;\n            (names[name] = self.getAll(name)).forEach(function(value) {\n              callback.call(thisArg, value, name, self);\n            });\n          });\n    };\n  }\n\n  /* istanbul ignore else */\n  if (!('keys' in URLSearchParamsProto)) {\n    URLSearchParamsProto.keys = function keys() {\n      return iterator(this, function(value, key) { this.push(key); });\n    };\n  }\n\n   /* istanbul ignore else */\n  if (!('values' in URLSearchParamsProto)) {\n    URLSearchParamsProto.values = function values() {\n      return iterator(this, function(value, key) { this.push(value); });\n    };\n  }\n\n  /* istanbul ignore else */\n  if (!('entries' in URLSearchParamsProto)) {\n    URLSearchParamsProto.entries = function entries() {\n      return iterator(this, function(value, key) { this.push([key, value]); });\n    };\n  }\n\n  /* istanbul ignore else */\n  if (iterable && !(Symbol.iterator in URLSearchParamsProto)) {\n    URLSearchParamsProto[Symbol.iterator] = URLSearchParamsProto.entries;\n  }\n\n  /* istanbul ignore else */\n  if (!('sort' in URLSearchParamsProto)) {\n    URLSearchParamsProto.sort = function sort() {\n      var\n        entries = this.entries(),\n        entry = entries.next(),\n        done = entry.done,\n        keys = [],\n        values = Object.create(null),\n        i, key, value\n      ;\n      while (!done) {\n        value = entry.value;\n        key = value[0];\n        keys.push(key);\n        if (!(key in values)) {\n          values[key] = [];\n        }\n        values[key].push(value[1]);\n        entry = entries.next();\n        done = entry.done;\n      }\n      // not the champion in efficiency\n      // but these two bits just do the job\n      keys.sort();\n      for (i = 0; i < keys.length; i++) {\n        this.delete(keys[i]);\n      }\n      for (i = 0; i < keys.length; i++) {\n        key = keys[i];\n        this.append(key, values[key].shift());\n      }\n    };\n  }\n\n  function iterator(self, callback) {\n    var items = [];\n    self.forEach(callback, items);\n    /* istanbul ignore next */\n    return iterable ?\n      items[Symbol.iterator]() :\n      {\n        next: function() {\n          var value = items.shift();\n          return {done: value === void 0, value: value};\n        }\n      };\n  }\n\n  /* istanbul ignore next */\n  (function (Object) {\n    var\n      dP = Object.defineProperty,\n      gOPD = Object.getOwnPropertyDescriptor,\n      createSearchParamsPollute = function (search) {\n        function append(name, value) {\n          URLSearchParamsProto.append.call(this, name, value);\n          name = this.toString();\n          search.set.call(this._usp, name ? ('?' + name) : '');\n        }\n        function del(name) {\n          URLSearchParamsProto.delete.call(this, name);\n          name = this.toString();\n          search.set.call(this._usp, name ? ('?' + name) : '');\n        }\n        function set(name, value) {\n          URLSearchParamsProto.set.call(this, name, value);\n          name = this.toString();\n          search.set.call(this._usp, name ? ('?' + name) : '');\n        }\n        return function (sp, value) {\n          sp.append = append;\n          sp.delete = del;\n          sp.set = set;\n          return dP(sp, '_usp', {\n            configurable: true,\n            writable: true,\n            value: value\n          });\n        };\n      },\n      createSearchParamsCreate = function (polluteSearchParams) {\n        return function (obj, sp) {\n          dP(\n            obj, '_searchParams', {\n              configurable: true,\n              writable: true,\n              value: polluteSearchParams(sp, obj)\n            }\n          );\n          return sp;\n        };\n      },\n      updateSearchParams = function (sp) {\n        var append = sp.append;\n        sp.append = URLSearchParamsProto.append;\n        URLSearchParams.call(sp, sp._usp.search.slice(1));\n        sp.append = append;\n      },\n      verifySearchParams = function (obj, Class) {\n        if (!(obj instanceof Class)) throw new TypeError(\n          \"'searchParams' accessed on an object that \" +\n          \"does not implement interface \" + Class.name\n        );\n      },\n      upgradeClass = function (Class) {\n        var\n          ClassProto = Class.prototype,\n          searchParams = gOPD(ClassProto, 'searchParams'),\n          href = gOPD(ClassProto, 'href'),\n          search = gOPD(ClassProto, 'search'),\n          createSearchParams\n        ;\n        if (!searchParams && search && search.set) {\n          createSearchParams = createSearchParamsCreate(\n            createSearchParamsPollute(search)\n          );\n          Object.defineProperties(\n            ClassProto,\n            {\n              href: {\n                get: function () {\n                  return href.get.call(this);\n                },\n                set: function (value) {\n                  var sp = this._searchParams;\n                  href.set.call(this, value);\n                  if (sp) updateSearchParams(sp);\n                }\n              },\n              search: {\n                get: function () {\n                  return search.get.call(this);\n                },\n                set: function (value) {\n                  var sp = this._searchParams;\n                  search.set.call(this, value);\n                  if (sp) updateSearchParams(sp);\n                }\n              },\n              searchParams: {\n                get: function () {\n                  verifySearchParams(this, Class);\n                  return this._searchParams || createSearchParams(\n                    this,\n                    new URLSearchParams(this.search.slice(1))\n                  );\n                },\n                set: function (sp) {\n                  verifySearchParams(this, Class);\n                  createSearchParams(this, sp);\n                }\n              }\n            }\n          );\n        }\n      }\n    ;\n    try {\n      upgradeClass(HTMLAnchorElement);\n      if (/^function|object$/.test(typeof URL) && URL.prototype)\n        upgradeClass(URL);\n    } catch (meh) {}\n  }(Object));\n\n}(self.URLSearchParams.prototype, Object));\n/* harmony default export */ __webpack_exports__[\"default\"] = (self.URLSearchParams);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0B1bmdhcC91cmwtc2VhcmNoLXBhcmFtcy9lc20vaW5kZXguanM/Yjg3NyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixRQUFRO0FBQ25DO0FBQ0E7QUFDQSwyQkFBMkIsUUFBUTtBQUNuQywyQkFBMkIsU0FBUztBQUNwQztBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNELHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsRUFBRTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLFlBQVk7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsWUFBWTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxZQUFZO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7O0FBRUE7O0FBRUE7QUFDQSxPQUFPLDhCQUE4QixFQUFFOztBQUV2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixXQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsZ0JBQWdCLEVBQUU7QUFDcEU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Qsa0JBQWtCLEVBQUU7QUFDdEU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QseUJBQXlCLEVBQUU7QUFDN0U7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixpQkFBaUI7QUFDbEM7QUFDQTtBQUNBLGlCQUFpQixpQkFBaUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVILENBQUM7QUFDYyxtRkFBb0IsRUFBQyIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9AdW5nYXAvdXJsLXNlYXJjaC1wYXJhbXMvZXNtL2luZGV4LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyohIChjKSBBbmRyZWEgR2lhbW1hcmNoaSAtIElTQyAqL1xudmFyIHNlbGYgPSB7fTtcbnRyeSB7XG4gIChmdW5jdGlvbiAoVVJMU2VhcmNoUGFyYW1zLCBwbHVzKSB7XG4gICAgaWYgKFxuICAgICAgbmV3IFVSTFNlYXJjaFBhcmFtcygncT0lMkInKS5nZXQoJ3EnKSAhPT0gcGx1cyB8fFxuICAgICAgbmV3IFVSTFNlYXJjaFBhcmFtcyh7cTogcGx1c30pLmdldCgncScpICE9PSBwbHVzIHx8XG4gICAgICBuZXcgVVJMU2VhcmNoUGFyYW1zKFtbJ3EnLCBwbHVzXV0pLmdldCgncScpICE9PSBwbHVzIHx8XG4gICAgICBuZXcgVVJMU2VhcmNoUGFyYW1zKCdxPVxcbicpLnRvU3RyaW5nKCkgIT09ICdxPSUwQScgfHxcbiAgICAgIG5ldyBVUkxTZWFyY2hQYXJhbXMoe3E6ICcgJid9KS50b1N0cmluZygpICE9PSAncT0rJTI2JyB8fFxuICAgICAgbmV3IFVSTFNlYXJjaFBhcmFtcyh7cTogJyV6eCd9KS50b1N0cmluZygpICE9PSAncT0lMjV6eCdcbiAgICApXG4gICAgICB0aHJvdyBVUkxTZWFyY2hQYXJhbXM7XG4gICAgc2VsZi5VUkxTZWFyY2hQYXJhbXMgPSBVUkxTZWFyY2hQYXJhbXM7XG4gIH0oVVJMU2VhcmNoUGFyYW1zLCAnKycpKTtcbn0gY2F0Y2goVVJMU2VhcmNoUGFyYW1zKSB7XG4gIChmdW5jdGlvbiAoT2JqZWN0LCBTdHJpbmcsIGlzQXJyYXkpIHsndXNlIHN0cmljdCc7XG4gICAgdmFyIGNyZWF0ZSA9IE9iamVjdC5jcmVhdGU7XG4gICAgdmFyIGRlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xuICAgIHZhciBmaW5kID0gL1shJ1xcKFxcKX5dfCUyMHwlMDAvZztcbiAgICB2YXIgZmluZFBlcmNlbnRTaWduID0gLyUoPyFbMC05YS1mQS1GXXsyfSkvZztcbiAgICB2YXIgcGx1cyA9IC9cXCsvZztcbiAgICB2YXIgcmVwbGFjZSA9IHtcbiAgICAgICchJzogJyUyMScsXG4gICAgICBcIidcIjogJyUyNycsXG4gICAgICAnKCc6ICclMjgnLFxuICAgICAgJyknOiAnJTI5JyxcbiAgICAgICd+JzogJyU3RScsXG4gICAgICAnJTIwJzogJysnLFxuICAgICAgJyUwMCc6ICdcXHgwMCdcbiAgICB9O1xuICAgIHZhciBwcm90byA9IHtcbiAgICAgIGFwcGVuZDogZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgICAgYXBwZW5kVG8odGhpcy5fdW5nYXAsIGtleSwgdmFsdWUpO1xuICAgICAgfSxcbiAgICAgIGRlbGV0ZTogZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBkZWxldGUgdGhpcy5fdW5nYXBba2V5XTtcbiAgICAgIH0sXG4gICAgICBnZXQ6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFzKGtleSkgPyB0aGlzLl91bmdhcFtrZXldWzBdIDogbnVsbDtcbiAgICAgIH0sXG4gICAgICBnZXRBbGw6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFzKGtleSkgPyB0aGlzLl91bmdhcFtrZXldLnNsaWNlKDApIDogW107XG4gICAgICB9LFxuICAgICAgaGFzOiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHJldHVybiBrZXkgaW4gdGhpcy5fdW5nYXA7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgICB0aGlzLl91bmdhcFtrZXldID0gW1N0cmluZyh2YWx1ZSldO1xuICAgICAgfSxcbiAgICAgIGZvckVhY2g6IGZ1bmN0aW9uIChjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBzZWxmLl91bmdhcClcbiAgICAgICAgICBzZWxmLl91bmdhcFtrZXldLmZvckVhY2goaW52b2tlLCBrZXkpO1xuICAgICAgICBmdW5jdGlvbiBpbnZva2UodmFsdWUpIHtcbiAgICAgICAgICBjYWxsYmFjay5jYWxsKHRoaXNBcmcsIHZhbHVlLCBTdHJpbmcoa2V5KSwgc2VsZik7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB0b0pTT046IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgfSxcbiAgICAgIHRvU3RyaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBxdWVyeSA9IFtdO1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5fdW5nYXApIHtcbiAgICAgICAgICB2YXIgZW5jb2RlZCA9IGVuY29kZShrZXkpO1xuICAgICAgICAgIGZvciAodmFyXG4gICAgICAgICAgICBpID0gMCxcbiAgICAgICAgICAgIHZhbHVlID0gdGhpcy5fdW5nYXBba2V5XTtcbiAgICAgICAgICAgIGkgPCB2YWx1ZS5sZW5ndGg7IGkrK1xuICAgICAgICAgICkge1xuICAgICAgICAgICAgcXVlcnkucHVzaChlbmNvZGVkICsgJz0nICsgZW5jb2RlKHZhbHVlW2ldKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBxdWVyeS5qb2luKCcmJyk7XG4gICAgICB9XG4gICAgfTtcbiAgICBmb3IgKHZhciBrZXkgaW4gcHJvdG8pXG4gICAgICBkZWZpbmVQcm9wZXJ0eShVUkxTZWFyY2hQYXJhbXMucHJvdG90eXBlLCBrZXksIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IHByb3RvW2tleV1cbiAgICAgIH0pO1xuICAgIHNlbGYuVVJMU2VhcmNoUGFyYW1zID0gVVJMU2VhcmNoUGFyYW1zO1xuICAgIGZ1bmN0aW9uIFVSTFNlYXJjaFBhcmFtcyhxdWVyeSkge1xuICAgICAgdmFyIGRpY3QgPSBjcmVhdGUobnVsbCk7XG4gICAgICBkZWZpbmVQcm9wZXJ0eSh0aGlzLCAnX3VuZ2FwJywge3ZhbHVlOiBkaWN0fSk7XG4gICAgICBzd2l0Y2ggKHRydWUpIHtcbiAgICAgICAgY2FzZSAhcXVlcnk6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgdHlwZW9mIHF1ZXJ5ID09PSAnc3RyaW5nJzpcbiAgICAgICAgICBpZiAocXVlcnkuY2hhckF0KDApID09PSAnPycpIHtcbiAgICAgICAgICAgIHF1ZXJ5ID0gcXVlcnkuc2xpY2UoMSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAodmFyXG4gICAgICAgICAgICBwYWlycyA9IHF1ZXJ5LnNwbGl0KCcmJyksXG4gICAgICAgICAgICBpID0gMCxcbiAgICAgICAgICAgIGxlbmd0aCA9IHBhaXJzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBwYWlyc1tpXTtcbiAgICAgICAgICAgIHZhciBpbmRleCA9IHZhbHVlLmluZGV4T2YoJz0nKTtcbiAgICAgICAgICAgIGlmICgtMSA8IGluZGV4KSB7XG4gICAgICAgICAgICAgIGFwcGVuZFRvKFxuICAgICAgICAgICAgICAgIGRpY3QsXG4gICAgICAgICAgICAgICAgZGVjb2RlKHZhbHVlLnNsaWNlKDAsIGluZGV4KSksXG4gICAgICAgICAgICAgICAgZGVjb2RlKHZhbHVlLnNsaWNlKGluZGV4ICsgMSkpXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHZhbHVlLmxlbmd0aCl7XG4gICAgICAgICAgICAgIGFwcGVuZFRvKFxuICAgICAgICAgICAgICAgIGRpY3QsXG4gICAgICAgICAgICAgICAgZGVjb2RlKHZhbHVlKSxcbiAgICAgICAgICAgICAgICAnJ1xuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBpc0FycmF5KHF1ZXJ5KTpcbiAgICAgICAgICBmb3IgKHZhclxuICAgICAgICAgICAgaSA9IDAsXG4gICAgICAgICAgICBsZW5ndGggPSBxdWVyeS5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrK1xuICAgICAgICAgICkge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gcXVlcnlbaV07XG4gICAgICAgICAgICBhcHBlbmRUbyhkaWN0LCB2YWx1ZVswXSwgdmFsdWVbMV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnZm9yRWFjaCcgaW4gcXVlcnk6XG4gICAgICAgICAgcXVlcnkuZm9yRWFjaChhZGRFYWNoLCBkaWN0KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gcXVlcnkpXG4gICAgICAgICAgICBhcHBlbmRUbyhkaWN0LCBrZXksIHF1ZXJ5W2tleV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkZEVhY2godmFsdWUsIGtleSkge1xuICAgICAgYXBwZW5kVG8odGhpcywga2V5LCB2YWx1ZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYXBwZW5kVG8oZGljdCwga2V5LCB2YWx1ZSkge1xuICAgICAgdmFyIHJlcyA9IGlzQXJyYXkodmFsdWUpID8gdmFsdWUuam9pbignLCcpIDogdmFsdWU7XG4gICAgICBpZiAoa2V5IGluIGRpY3QpXG4gICAgICAgIGRpY3Rba2V5XS5wdXNoKHJlcyk7XG4gICAgICBlbHNlXG4gICAgICAgIGRpY3Rba2V5XSA9IFtyZXNdO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRlY29kZShzdHIpIHtcbiAgICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoc3RyLnJlcGxhY2UoZmluZFBlcmNlbnRTaWduLCAnJTI1JykucmVwbGFjZShwbHVzLCAnICcpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBlbmNvZGUoc3RyKSB7XG4gICAgICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KHN0cikucmVwbGFjZShmaW5kLCByZXBsYWNlcik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVwbGFjZXIobWF0Y2gpIHtcbiAgICAgIHJldHVybiByZXBsYWNlW21hdGNoXTtcbiAgICB9XG5cbiAgfShPYmplY3QsIFN0cmluZywgQXJyYXkuaXNBcnJheSkpO1xufVxuXG4oZnVuY3Rpb24gKFVSTFNlYXJjaFBhcmFtc1Byb3RvKSB7XG5cbiAgdmFyIGl0ZXJhYmxlID0gZmFsc2U7XG4gIHRyeSB7IGl0ZXJhYmxlID0gISFTeW1ib2wuaXRlcmF0b3I7IH0gY2F0Y2ggKG9fTykge31cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAoISgnZm9yRWFjaCcgaW4gVVJMU2VhcmNoUGFyYW1zUHJvdG8pKSB7XG4gICAgVVJMU2VhcmNoUGFyYW1zUHJvdG8uZm9yRWFjaCA9IGZ1bmN0aW9uIGZvckVhY2goY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciBuYW1lcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICB0aGlzLnRvU3RyaW5nKClcbiAgICAgICAgICAucmVwbGFjZSgvPVtcXHNcXFNdKj8oPzomfCQpL2csICc9JylcbiAgICAgICAgICAuc3BsaXQoJz0nKVxuICAgICAgICAgIC5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICBpZiAoIW5hbWUubGVuZ3RoIHx8IG5hbWUgaW4gbmFtZXMpXG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIChuYW1lc1tuYW1lXSA9IHNlbGYuZ2V0QWxsKG5hbWUpKS5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgIGNhbGxiYWNrLmNhbGwodGhpc0FyZywgdmFsdWUsIG5hbWUsIHNlbGYpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgfTtcbiAgfVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmICghKCdrZXlzJyBpbiBVUkxTZWFyY2hQYXJhbXNQcm90bykpIHtcbiAgICBVUkxTZWFyY2hQYXJhbXNQcm90by5rZXlzID0gZnVuY3Rpb24ga2V5cygpIHtcbiAgICAgIHJldHVybiBpdGVyYXRvcih0aGlzLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7IHRoaXMucHVzaChrZXkpOyB9KTtcbiAgICB9O1xuICB9XG5cbiAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmICghKCd2YWx1ZXMnIGluIFVSTFNlYXJjaFBhcmFtc1Byb3RvKSkge1xuICAgIFVSTFNlYXJjaFBhcmFtc1Byb3RvLnZhbHVlcyA9IGZ1bmN0aW9uIHZhbHVlcygpIHtcbiAgICAgIHJldHVybiBpdGVyYXRvcih0aGlzLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7IHRoaXMucHVzaCh2YWx1ZSk7IH0pO1xuICAgIH07XG4gIH1cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAoISgnZW50cmllcycgaW4gVVJMU2VhcmNoUGFyYW1zUHJvdG8pKSB7XG4gICAgVVJMU2VhcmNoUGFyYW1zUHJvdG8uZW50cmllcyA9IGZ1bmN0aW9uIGVudHJpZXMoKSB7XG4gICAgICByZXR1cm4gaXRlcmF0b3IodGhpcywgZnVuY3Rpb24odmFsdWUsIGtleSkgeyB0aGlzLnB1c2goW2tleSwgdmFsdWVdKTsgfSk7XG4gICAgfTtcbiAgfVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmIChpdGVyYWJsZSAmJiAhKFN5bWJvbC5pdGVyYXRvciBpbiBVUkxTZWFyY2hQYXJhbXNQcm90bykpIHtcbiAgICBVUkxTZWFyY2hQYXJhbXNQcm90b1tTeW1ib2wuaXRlcmF0b3JdID0gVVJMU2VhcmNoUGFyYW1zUHJvdG8uZW50cmllcztcbiAgfVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmICghKCdzb3J0JyBpbiBVUkxTZWFyY2hQYXJhbXNQcm90bykpIHtcbiAgICBVUkxTZWFyY2hQYXJhbXNQcm90by5zb3J0ID0gZnVuY3Rpb24gc29ydCgpIHtcbiAgICAgIHZhclxuICAgICAgICBlbnRyaWVzID0gdGhpcy5lbnRyaWVzKCksXG4gICAgICAgIGVudHJ5ID0gZW50cmllcy5uZXh0KCksXG4gICAgICAgIGRvbmUgPSBlbnRyeS5kb25lLFxuICAgICAgICBrZXlzID0gW10sXG4gICAgICAgIHZhbHVlcyA9IE9iamVjdC5jcmVhdGUobnVsbCksXG4gICAgICAgIGksIGtleSwgdmFsdWVcbiAgICAgIDtcbiAgICAgIHdoaWxlICghZG9uZSkge1xuICAgICAgICB2YWx1ZSA9IGVudHJ5LnZhbHVlO1xuICAgICAgICBrZXkgPSB2YWx1ZVswXTtcbiAgICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgICAgIGlmICghKGtleSBpbiB2YWx1ZXMpKSB7XG4gICAgICAgICAgdmFsdWVzW2tleV0gPSBbXTtcbiAgICAgICAgfVxuICAgICAgICB2YWx1ZXNba2V5XS5wdXNoKHZhbHVlWzFdKTtcbiAgICAgICAgZW50cnkgPSBlbnRyaWVzLm5leHQoKTtcbiAgICAgICAgZG9uZSA9IGVudHJ5LmRvbmU7XG4gICAgICB9XG4gICAgICAvLyBub3QgdGhlIGNoYW1waW9uIGluIGVmZmljaWVuY3lcbiAgICAgIC8vIGJ1dCB0aGVzZSB0d28gYml0cyBqdXN0IGRvIHRoZSBqb2JcbiAgICAgIGtleXMuc29ydCgpO1xuICAgICAgZm9yIChpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5kZWxldGUoa2V5c1tpXSk7XG4gICAgICB9XG4gICAgICBmb3IgKGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgICB0aGlzLmFwcGVuZChrZXksIHZhbHVlc1trZXldLnNoaWZ0KCkpO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBpdGVyYXRvcihzZWxmLCBjYWxsYmFjaykge1xuICAgIHZhciBpdGVtcyA9IFtdO1xuICAgIHNlbGYuZm9yRWFjaChjYWxsYmFjaywgaXRlbXMpO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcmV0dXJuIGl0ZXJhYmxlID9cbiAgICAgIGl0ZW1zW1N5bWJvbC5pdGVyYXRvcl0oKSA6XG4gICAgICB7XG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciB2YWx1ZSA9IGl0ZW1zLnNoaWZ0KCk7XG4gICAgICAgICAgcmV0dXJuIHtkb25lOiB2YWx1ZSA9PT0gdm9pZCAwLCB2YWx1ZTogdmFsdWV9O1xuICAgICAgICB9XG4gICAgICB9O1xuICB9XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgKGZ1bmN0aW9uIChPYmplY3QpIHtcbiAgICB2YXJcbiAgICAgIGRQID0gT2JqZWN0LmRlZmluZVByb3BlcnR5LFxuICAgICAgZ09QRCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IsXG4gICAgICBjcmVhdGVTZWFyY2hQYXJhbXNQb2xsdXRlID0gZnVuY3Rpb24gKHNlYXJjaCkge1xuICAgICAgICBmdW5jdGlvbiBhcHBlbmQobmFtZSwgdmFsdWUpIHtcbiAgICAgICAgICBVUkxTZWFyY2hQYXJhbXNQcm90by5hcHBlbmQuY2FsbCh0aGlzLCBuYW1lLCB2YWx1ZSk7XG4gICAgICAgICAgbmFtZSA9IHRoaXMudG9TdHJpbmcoKTtcbiAgICAgICAgICBzZWFyY2guc2V0LmNhbGwodGhpcy5fdXNwLCBuYW1lID8gKCc/JyArIG5hbWUpIDogJycpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGRlbChuYW1lKSB7XG4gICAgICAgICAgVVJMU2VhcmNoUGFyYW1zUHJvdG8uZGVsZXRlLmNhbGwodGhpcywgbmFtZSk7XG4gICAgICAgICAgbmFtZSA9IHRoaXMudG9TdHJpbmcoKTtcbiAgICAgICAgICBzZWFyY2guc2V0LmNhbGwodGhpcy5fdXNwLCBuYW1lID8gKCc/JyArIG5hbWUpIDogJycpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHNldChuYW1lLCB2YWx1ZSkge1xuICAgICAgICAgIFVSTFNlYXJjaFBhcmFtc1Byb3RvLnNldC5jYWxsKHRoaXMsIG5hbWUsIHZhbHVlKTtcbiAgICAgICAgICBuYW1lID0gdGhpcy50b1N0cmluZygpO1xuICAgICAgICAgIHNlYXJjaC5zZXQuY2FsbCh0aGlzLl91c3AsIG5hbWUgPyAoJz8nICsgbmFtZSkgOiAnJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChzcCwgdmFsdWUpIHtcbiAgICAgICAgICBzcC5hcHBlbmQgPSBhcHBlbmQ7XG4gICAgICAgICAgc3AuZGVsZXRlID0gZGVsO1xuICAgICAgICAgIHNwLnNldCA9IHNldDtcbiAgICAgICAgICByZXR1cm4gZFAoc3AsICdfdXNwJywge1xuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICBjcmVhdGVTZWFyY2hQYXJhbXNDcmVhdGUgPSBmdW5jdGlvbiAocG9sbHV0ZVNlYXJjaFBhcmFtcykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG9iaiwgc3ApIHtcbiAgICAgICAgICBkUChcbiAgICAgICAgICAgIG9iaiwgJ19zZWFyY2hQYXJhbXMnLCB7XG4gICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICAgIHZhbHVlOiBwb2xsdXRlU2VhcmNoUGFyYW1zKHNwLCBvYmopXG4gICAgICAgICAgICB9XG4gICAgICAgICAgKTtcbiAgICAgICAgICByZXR1cm4gc3A7XG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgdXBkYXRlU2VhcmNoUGFyYW1zID0gZnVuY3Rpb24gKHNwKSB7XG4gICAgICAgIHZhciBhcHBlbmQgPSBzcC5hcHBlbmQ7XG4gICAgICAgIHNwLmFwcGVuZCA9IFVSTFNlYXJjaFBhcmFtc1Byb3RvLmFwcGVuZDtcbiAgICAgICAgVVJMU2VhcmNoUGFyYW1zLmNhbGwoc3AsIHNwLl91c3Auc2VhcmNoLnNsaWNlKDEpKTtcbiAgICAgICAgc3AuYXBwZW5kID0gYXBwZW5kO1xuICAgICAgfSxcbiAgICAgIHZlcmlmeVNlYXJjaFBhcmFtcyA9IGZ1bmN0aW9uIChvYmosIENsYXNzKSB7XG4gICAgICAgIGlmICghKG9iaiBpbnN0YW5jZW9mIENsYXNzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICBcIidzZWFyY2hQYXJhbXMnIGFjY2Vzc2VkIG9uIGFuIG9iamVjdCB0aGF0IFwiICtcbiAgICAgICAgICBcImRvZXMgbm90IGltcGxlbWVudCBpbnRlcmZhY2UgXCIgKyBDbGFzcy5uYW1lXG4gICAgICAgICk7XG4gICAgICB9LFxuICAgICAgdXBncmFkZUNsYXNzID0gZnVuY3Rpb24gKENsYXNzKSB7XG4gICAgICAgIHZhclxuICAgICAgICAgIENsYXNzUHJvdG8gPSBDbGFzcy5wcm90b3R5cGUsXG4gICAgICAgICAgc2VhcmNoUGFyYW1zID0gZ09QRChDbGFzc1Byb3RvLCAnc2VhcmNoUGFyYW1zJyksXG4gICAgICAgICAgaHJlZiA9IGdPUEQoQ2xhc3NQcm90bywgJ2hyZWYnKSxcbiAgICAgICAgICBzZWFyY2ggPSBnT1BEKENsYXNzUHJvdG8sICdzZWFyY2gnKSxcbiAgICAgICAgICBjcmVhdGVTZWFyY2hQYXJhbXNcbiAgICAgICAgO1xuICAgICAgICBpZiAoIXNlYXJjaFBhcmFtcyAmJiBzZWFyY2ggJiYgc2VhcmNoLnNldCkge1xuICAgICAgICAgIGNyZWF0ZVNlYXJjaFBhcmFtcyA9IGNyZWF0ZVNlYXJjaFBhcmFtc0NyZWF0ZShcbiAgICAgICAgICAgIGNyZWF0ZVNlYXJjaFBhcmFtc1BvbGx1dGUoc2VhcmNoKVxuICAgICAgICAgICk7XG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoXG4gICAgICAgICAgICBDbGFzc1Byb3RvLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBocmVmOiB7XG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gaHJlZi5nZXQuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgc3AgPSB0aGlzLl9zZWFyY2hQYXJhbXM7XG4gICAgICAgICAgICAgICAgICBocmVmLnNldC5jYWxsKHRoaXMsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgIGlmIChzcCkgdXBkYXRlU2VhcmNoUGFyYW1zKHNwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHNlYXJjaDoge1xuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlYXJjaC5nZXQuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgc3AgPSB0aGlzLl9zZWFyY2hQYXJhbXM7XG4gICAgICAgICAgICAgICAgICBzZWFyY2guc2V0LmNhbGwodGhpcywgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgaWYgKHNwKSB1cGRhdGVTZWFyY2hQYXJhbXMoc3ApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgc2VhcmNoUGFyYW1zOiB7XG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICB2ZXJpZnlTZWFyY2hQYXJhbXModGhpcywgQ2xhc3MpO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NlYXJjaFBhcmFtcyB8fCBjcmVhdGVTZWFyY2hQYXJhbXMoXG4gICAgICAgICAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAgICAgICAgIG5ldyBVUkxTZWFyY2hQYXJhbXModGhpcy5zZWFyY2guc2xpY2UoMSkpXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAoc3ApIHtcbiAgICAgICAgICAgICAgICAgIHZlcmlmeVNlYXJjaFBhcmFtcyh0aGlzLCBDbGFzcyk7XG4gICAgICAgICAgICAgICAgICBjcmVhdGVTZWFyY2hQYXJhbXModGhpcywgc3ApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICA7XG4gICAgdHJ5IHtcbiAgICAgIHVwZ3JhZGVDbGFzcyhIVE1MQW5jaG9yRWxlbWVudCk7XG4gICAgICBpZiAoL15mdW5jdGlvbnxvYmplY3QkLy50ZXN0KHR5cGVvZiBVUkwpICYmIFVSTC5wcm90b3R5cGUpXG4gICAgICAgIHVwZ3JhZGVDbGFzcyhVUkwpO1xuICAgIH0gY2F0Y2ggKG1laCkge31cbiAgfShPYmplY3QpKTtcblxufShzZWxmLlVSTFNlYXJjaFBhcmFtcy5wcm90b3R5cGUsIE9iamVjdCkpO1xuZXhwb3J0IGRlZmF1bHQgc2VsZi5VUkxTZWFyY2hQYXJhbXM7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@ungap/url-search-params/esm/index.js\n");

/***/ }),

/***/ "./node_modules/imdb-api/lib/imdb.js":
/*!*******************************************!*\
  !*** ./node_modules/imdb-api/lib/imdb.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Client = exports.search = exports.get = exports.ImdbError = exports.SearchResults = exports.SearchResult = exports.Game = exports.TVShow = exports.Episode = exports.Movie = exports.Rating = void 0;\nvar ky_universal_1 = __importDefault(__webpack_require__(/*! ky-universal */ \"./node_modules/ky-universal/browser.js\"));\nvar url_search_params_1 = __importDefault(__webpack_require__(/*! @ungap/url-search-params */ \"./node_modules/@ungap/url-search-params/esm/index.js\"));\nvar interfaces_1 = __webpack_require__(/*! ./interfaces */ \"./node_modules/imdb-api/lib/interfaces.js\");\nvar omdbapi = new URL(\"https://www.omdbapi.com\");\nfunction isRequestType(reqtype) {\n    if (reqtype === \"movie\" ||\n        reqtype === \"series\" ||\n        reqtype === \"episode\" ||\n        reqtype === \"game\") {\n        return true;\n    }\n    return false;\n}\nfunction reqtoqueryobj(req, apikey, page) {\n    var r = new url_search_params_1.default({\n        apikey: apikey,\n        s: req.name,\n        page: String(page),\n        r: \"json\",\n    });\n    if (req.year !== undefined) {\n        r.append(\"y\", String(req.year));\n    }\n    if (req.reqtype !== undefined) {\n        r.append(\"type\", String(req.reqtype));\n    }\n    return r;\n}\nvar Rating = (function () {\n    function Rating(source, value) {\n        this.source = source;\n        this.value = value;\n    }\n    return Rating;\n}());\nexports.Rating = Rating;\nvar Movie = (function () {\n    function Movie(obj) {\n        this.ratings = [];\n        this.title = obj.Title;\n        this.year = 0;\n        this._yearData = \"\";\n        if (obj.Year !== undefined) {\n            this._yearData = obj.Year;\n            if (!obj.Year.match(/\\d{4}[-â€“](?:\\d{4})?/)) {\n                var rawYear = parseInt(obj.Year, 10);\n                if (isNaN(rawYear)) {\n                    throw new TypeError(\"invalid year\");\n                }\n                this.year = rawYear;\n            }\n            else {\n                this.year = 0;\n            }\n        }\n        this.rated = obj.Rated;\n        var rawReleased = new Date(obj.Released);\n        if (isNaN(rawReleased.getTime())) {\n            this.released = undefined;\n        }\n        else {\n            this.released = rawReleased;\n        }\n        this.runtime = obj.Runtime;\n        this.genres = obj.Genre;\n        this.director = obj.Director;\n        this.writer = obj.Writer;\n        this.actors = obj.Actors;\n        this.plot = obj.Plot;\n        this.languages = obj.Language;\n        this.country = obj.Country;\n        this.awards = obj.Awards;\n        this.poster = obj.Poster;\n        this.metascore = obj.Metascore;\n        var rawRating = parseFloat(obj.imdbRating);\n        this.rating = isNaN(rawRating) ? 0 : rawRating;\n        this.votes = obj.imdbVotes;\n        this.imdbid = obj.imdbID;\n        this.type = \"episode\";\n        if (obj.Type !== undefined) {\n            if (!isRequestType(obj.Type)) {\n                throw new TypeError(obj.Type + \" is not a valid RequestType\");\n            }\n            this.type = obj.Type;\n        }\n        if (obj.Ratings !== undefined) {\n            for (var _i = 0, _a = obj.Ratings; _i < _a.length; _i++) {\n                var rating = _a[_i];\n                this.ratings.push(new Rating(rating.Source, rating.Value));\n            }\n        }\n        if (obj.DVD !== undefined) {\n            var rawDvd = new Date(obj.DVD);\n            if (isNaN(rawDvd.getTime())) {\n                this.dvd = undefined;\n            }\n            else {\n                this.dvd = rawDvd;\n            }\n        }\n        this.boxoffice = obj.BoxOffice;\n        this.production = obj.Production;\n        this.website = obj.Website;\n        this.name = this.title;\n        this.series = this.type === \"series\";\n        this.imdburl = \"https://www.imdb.com/title/\" + this.imdbid;\n    }\n    return Movie;\n}());\nexports.Movie = Movie;\nvar Episode = (function (_super) {\n    __extends(Episode, _super);\n    function Episode(obj, season) {\n        var _this = _super.call(this, obj) || this;\n        if (season !== undefined) {\n            _this.season = season;\n        }\n        else {\n            _this.season = parseInt(obj.Season, 10);\n            if (isNaN(_this.season)) {\n                throw new TypeError(\"invalid season\");\n            }\n        }\n        _this.seriesid = obj.seriesID;\n        if (\"Episode\" in obj) {\n            _this.episode = parseInt(obj.Episode, 10);\n            if (isNaN(_this.episode)) {\n                throw new TypeError(\"invalid episode\");\n            }\n        }\n        else {\n            _this.episode = 0;\n        }\n        return _this;\n    }\n    return Episode;\n}(Movie));\nexports.Episode = Episode;\nvar TVShow = (function (_super) {\n    __extends(TVShow, _super);\n    function TVShow(obj, opts) {\n        var _this = _super.call(this, obj) || this;\n        _this._episodes = [];\n        var years = _this._yearData.split(\"-\");\n        _this.start_year = parseInt(years[0], 10);\n        _this.end_year = parseInt(years[1], 10) ? parseInt(years[1], 10) : undefined;\n        _this.totalseasons = parseInt(obj.totalSeasons, 10);\n        _this.opts = opts;\n        if (opts.baseURL && typeof opts.baseURL === \"string\") {\n            opts.baseURL = new URL(opts.baseURL);\n            _this.baseURL = opts.baseURL;\n        }\n        else if (opts.baseURL && opts.baseURL instanceof URL) {\n            _this.baseURL = opts.baseURL;\n        }\n        else {\n            _this.baseURL = omdbapi;\n        }\n        return _this;\n    }\n    TVShow.prototype.episodes = function () {\n        var _this = this;\n        if (this._episodes.length !== 0) {\n            return Promise.resolve(this._episodes);\n        }\n        if (this.opts.apiKey === undefined) {\n            throw new ImdbError(\"Missing api key in opts\");\n        }\n        var funcs = [];\n        for (var i = 1; i <= this.totalseasons; i++) {\n            var qs_1 = new url_search_params_1.default({\n                Season: String(i),\n                apikey: this.opts.apiKey,\n                i: this.imdbid,\n                r: \"json\",\n            });\n            var reqopts = {\n                searchParams: qs_1,\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                },\n                timeout: undefined,\n                prefixUrl: this.baseURL,\n            };\n            if (this.opts.timeout !== undefined) {\n                reqopts.timeout = this.opts.timeout;\n            }\n            funcs.push(ky_universal_1.default(\"\", reqopts).json());\n        }\n        var prom = Promise.all(funcs)\n            .then(function (result) {\n            if (interfaces_1.assertEpisodeSeasonResponse(result)) {\n                return Promise.resolve(result);\n            }\n            return Promise.reject(new TypeError(\"Invalid response from server\"));\n        })\n            .then(function (epData) {\n            var eps = [];\n            for (var _i = 0, epData_1 = epData; _i < epData_1.length; _i++) {\n                var datum = epData_1[_i];\n                if (interfaces_1.isError(datum)) {\n                    throw new ImdbError(datum.Error);\n                }\n                var season = parseInt(datum.Season, 10);\n                for (var _a = 0, _b = datum.Episodes; _a < _b.length; _a++) {\n                    var ep = _b[_a];\n                    eps.push(new Episode(ep, season));\n                }\n            }\n            _this._episodes = eps;\n            return Promise.resolve(eps);\n        });\n        return prom;\n    };\n    return TVShow;\n}(Movie));\nexports.TVShow = TVShow;\nvar Game = (function (_super) {\n    __extends(Game, _super);\n    function Game() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    return Game;\n}(Movie));\nexports.Game = Game;\nvar SearchResult = (function () {\n    function SearchResult(obj) {\n        this.title = obj.Title;\n        this.year = parseInt(obj.Year, 10);\n        this.imdbid = obj.imdbID;\n        if (!isRequestType(obj.Type)) {\n            throw new TypeError(obj.Type + \" is not a valid RequestType\");\n        }\n        this.type = obj.Type;\n        this.poster = obj.Poster;\n        this.name = this.title;\n    }\n    return SearchResult;\n}());\nexports.SearchResult = SearchResult;\nvar SearchResults = (function () {\n    function SearchResults(obj, page, opts, req) {\n        this.results = [];\n        this.page = page;\n        this.req = req;\n        this.opts = opts;\n        for (var _i = 0, _a = obj.Search; _i < _a.length; _i++) {\n            var result = _a[_i];\n            this.results.push(new SearchResult(result));\n        }\n        this.totalresults = parseInt(obj.totalResults, 10);\n    }\n    SearchResults.prototype.next = function () {\n        return search(this.req, this.opts, this.page + 1);\n    };\n    return SearchResults;\n}());\nexports.SearchResults = SearchResults;\nvar ImdbError = (function () {\n    function ImdbError(message) {\n        this.message = message;\n        this.name = \"imdb api error\";\n    }\n    return ImdbError;\n}());\nexports.ImdbError = ImdbError;\nfunction get(req, opts) {\n    try {\n        return new Client(opts).get(req);\n    }\n    catch (e) {\n        return Promise.reject(e);\n    }\n}\nexports.get = get;\nfunction search(req, opts, page) {\n    return new Client(opts).search(req, page);\n}\nexports.search = search;\nvar Client = (function () {\n    function Client(opts) {\n        if (!Object.prototype.hasOwnProperty.call(opts, \"apiKey\")) {\n            throw new ImdbError(\"Missing api key in opts\");\n        }\n        this.opts = opts;\n        if (opts.baseURL && typeof opts.baseURL === \"string\") {\n            opts.baseURL = new URL(opts.baseURL);\n            this.baseURL = opts.baseURL;\n        }\n        else if (opts.baseURL && opts.baseURL instanceof URL) {\n            this.baseURL = opts.baseURL;\n        }\n        else {\n            this.baseURL = omdbapi;\n        }\n    }\n    Client.prototype.get = function (req, opts) {\n        var mergedOpts = this.mergeOpts(opts);\n        if (mergedOpts.apiKey === undefined) {\n            throw new ImdbError(\"Missing api key in opts\");\n        }\n        var qs = new url_search_params_1.default({\n            apikey: mergedOpts.apiKey,\n            plot: req.short_plot ? \"short\" : \"full\",\n            r: \"json\",\n        });\n        if (req.year !== undefined) {\n            qs.append(\"y\", String(req.year));\n        }\n        if (req.name) {\n            qs.append(\"t\", req.name);\n        }\n        else if (req.id) {\n            qs.append(\"i\", req.id);\n        }\n        else {\n            return Promise.reject(new ImdbError(\"Missing one of req.id or req.name\"));\n        }\n        var reqopts = {\n            headers: {\n                \"Content-Type\": \"application/json\",\n            },\n            searchParams: qs,\n            timeout: undefined,\n            prefixUrl: this.baseURL,\n        };\n        if (\"timeout\" in mergedOpts) {\n            reqopts.timeout = mergedOpts.timeout;\n        }\n        var prom = ky_universal_1.default(\"\", reqopts)\n            .json()\n            .then(function (response) {\n            if (interfaces_1.assertGetResponse(response)) {\n                return Promise.resolve(response);\n            }\n            return Promise.reject(new TypeError(\"Invalid response from server\"));\n        })\n            .then(function (data) {\n            var ret;\n            if (interfaces_1.isError(data)) {\n                throw new ImdbError(data.Error + \": \" + (req.name ? req.name : req.id));\n            }\n            if (interfaces_1.isMovie(data)) {\n                ret = new Movie(data);\n            }\n            else if (interfaces_1.isGame(data)) {\n                ret = new Game(data);\n            }\n            else if (interfaces_1.isTvshow(data)) {\n                ret = new TVShow(data, mergedOpts);\n            }\n            else if (interfaces_1.isEpisode(data)) {\n                ret = new Episode(data);\n            }\n            else {\n                throw new ImdbError(\"type: '\" + data.Type + \"' is not valid\");\n            }\n            return Promise.resolve(ret);\n        });\n        return prom;\n    };\n    Client.prototype.search = function (req, page, opts) {\n        var mergedOpts = this.mergeOpts(opts);\n        if (page === undefined) {\n            page = 1;\n        }\n        if (mergedOpts.apiKey === undefined) {\n            throw new ImdbError(\"Missing api key in opts\");\n        }\n        var qs = reqtoqueryobj(req, mergedOpts.apiKey, page);\n        var reqopts = {\n            searchParams: qs,\n            headers: {\n                \"Content-Type\": \"application/json\",\n            },\n            timeout: undefined,\n            prefixUrl: this.baseURL,\n        };\n        if (mergedOpts.timeout) {\n            reqopts.timeout = mergedOpts.timeout;\n        }\n        var prom = ky_universal_1.default(\"\", reqopts)\n            .json()\n            .then(function (response) {\n            if (interfaces_1.assertSearchResponse(response)) {\n                return Promise.resolve(response);\n            }\n            return Promise.reject(new TypeError(\"Invalid response from server\"));\n        })\n            .then(function (data) {\n            if (interfaces_1.isError(data)) {\n                throw new ImdbError(data.Error + \": \" + req.name);\n            }\n            if (page === undefined) {\n                page = 0;\n            }\n            return Promise.resolve(new SearchResults(data, page, mergedOpts, req));\n        });\n        return prom;\n    };\n    Client.prototype.mergeOpts = function (opts) {\n        if (opts !== undefined) {\n            return __assign(__assign({}, this.opts), opts);\n        }\n        return __assign({}, this.opts);\n    };\n    return Client;\n}());\nexports.Client = Client;\n//# sourceMappingURL=imdb.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2ltZGItYXBpL2xpYi9pbWRiLmpzP2M3N2EiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxjQUFjLGdCQUFnQixzQ0FBc0MsaUJBQWlCLEVBQUU7QUFDdkYsNkJBQTZCLDhFQUE4RTtBQUMzRztBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixzQkFBc0I7QUFDN0M7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsZ0RBQWdELE9BQU87QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0EsOENBQThDLGNBQWM7QUFDNUQ7QUFDQSxxQ0FBcUMsbUJBQU8sQ0FBQyw0REFBYztBQUMzRCwwQ0FBMEMsbUJBQU8sQ0FBQyxzRkFBMEI7QUFDNUUsbUJBQW1CLG1CQUFPLENBQUMsK0RBQWM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsRUFBRSxVQUFVLEVBQUU7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxnQkFBZ0I7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHdCQUF3QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLCtDQUErQyxzQkFBc0I7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxnQkFBZ0I7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLGdCQUFnQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9pbWRiLWFwaS9saWIvaW1kYi5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfX2Fzc2lnbiA9ICh0aGlzICYmIHRoaXMuX19hc3NpZ24pIHx8IGZ1bmN0aW9uICgpIHtcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24odCkge1xuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpXG4gICAgICAgICAgICAgICAgdFtwXSA9IHNbcF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfTtcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNsaWVudCA9IGV4cG9ydHMuc2VhcmNoID0gZXhwb3J0cy5nZXQgPSBleHBvcnRzLkltZGJFcnJvciA9IGV4cG9ydHMuU2VhcmNoUmVzdWx0cyA9IGV4cG9ydHMuU2VhcmNoUmVzdWx0ID0gZXhwb3J0cy5HYW1lID0gZXhwb3J0cy5UVlNob3cgPSBleHBvcnRzLkVwaXNvZGUgPSBleHBvcnRzLk1vdmllID0gZXhwb3J0cy5SYXRpbmcgPSB2b2lkIDA7XG52YXIga3lfdW5pdmVyc2FsXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImt5LXVuaXZlcnNhbFwiKSk7XG52YXIgdXJsX3NlYXJjaF9wYXJhbXNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiQHVuZ2FwL3VybC1zZWFyY2gtcGFyYW1zXCIpKTtcbnZhciBpbnRlcmZhY2VzXzEgPSByZXF1aXJlKFwiLi9pbnRlcmZhY2VzXCIpO1xudmFyIG9tZGJhcGkgPSBuZXcgVVJMKFwiaHR0cHM6Ly93d3cub21kYmFwaS5jb21cIik7XG5mdW5jdGlvbiBpc1JlcXVlc3RUeXBlKHJlcXR5cGUpIHtcbiAgICBpZiAocmVxdHlwZSA9PT0gXCJtb3ZpZVwiIHx8XG4gICAgICAgIHJlcXR5cGUgPT09IFwic2VyaWVzXCIgfHxcbiAgICAgICAgcmVxdHlwZSA9PT0gXCJlcGlzb2RlXCIgfHxcbiAgICAgICAgcmVxdHlwZSA9PT0gXCJnYW1lXCIpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIHJlcXRvcXVlcnlvYmoocmVxLCBhcGlrZXksIHBhZ2UpIHtcbiAgICB2YXIgciA9IG5ldyB1cmxfc2VhcmNoX3BhcmFtc18xLmRlZmF1bHQoe1xuICAgICAgICBhcGlrZXk6IGFwaWtleSxcbiAgICAgICAgczogcmVxLm5hbWUsXG4gICAgICAgIHBhZ2U6IFN0cmluZyhwYWdlKSxcbiAgICAgICAgcjogXCJqc29uXCIsXG4gICAgfSk7XG4gICAgaWYgKHJlcS55ZWFyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgci5hcHBlbmQoXCJ5XCIsIFN0cmluZyhyZXEueWVhcikpO1xuICAgIH1cbiAgICBpZiAocmVxLnJlcXR5cGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByLmFwcGVuZChcInR5cGVcIiwgU3RyaW5nKHJlcS5yZXF0eXBlKSk7XG4gICAgfVxuICAgIHJldHVybiByO1xufVxudmFyIFJhdGluZyA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUmF0aW5nKHNvdXJjZSwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIFJhdGluZztcbn0oKSk7XG5leHBvcnRzLlJhdGluZyA9IFJhdGluZztcbnZhciBNb3ZpZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTW92aWUob2JqKSB7XG4gICAgICAgIHRoaXMucmF0aW5ncyA9IFtdO1xuICAgICAgICB0aGlzLnRpdGxlID0gb2JqLlRpdGxlO1xuICAgICAgICB0aGlzLnllYXIgPSAwO1xuICAgICAgICB0aGlzLl95ZWFyRGF0YSA9IFwiXCI7XG4gICAgICAgIGlmIChvYmouWWVhciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLl95ZWFyRGF0YSA9IG9iai5ZZWFyO1xuICAgICAgICAgICAgaWYgKCFvYmouWWVhci5tYXRjaCgvXFxkezR9Wy3igJNdKD86XFxkezR9KT8vKSkge1xuICAgICAgICAgICAgICAgIHZhciByYXdZZWFyID0gcGFyc2VJbnQob2JqLlllYXIsIDEwKTtcbiAgICAgICAgICAgICAgICBpZiAoaXNOYU4ocmF3WWVhcikpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgeWVhclwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy55ZWFyID0gcmF3WWVhcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMueWVhciA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yYXRlZCA9IG9iai5SYXRlZDtcbiAgICAgICAgdmFyIHJhd1JlbGVhc2VkID0gbmV3IERhdGUob2JqLlJlbGVhc2VkKTtcbiAgICAgICAgaWYgKGlzTmFOKHJhd1JlbGVhc2VkLmdldFRpbWUoKSkpIHtcbiAgICAgICAgICAgIHRoaXMucmVsZWFzZWQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnJlbGVhc2VkID0gcmF3UmVsZWFzZWQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ydW50aW1lID0gb2JqLlJ1bnRpbWU7XG4gICAgICAgIHRoaXMuZ2VucmVzID0gb2JqLkdlbnJlO1xuICAgICAgICB0aGlzLmRpcmVjdG9yID0gb2JqLkRpcmVjdG9yO1xuICAgICAgICB0aGlzLndyaXRlciA9IG9iai5Xcml0ZXI7XG4gICAgICAgIHRoaXMuYWN0b3JzID0gb2JqLkFjdG9ycztcbiAgICAgICAgdGhpcy5wbG90ID0gb2JqLlBsb3Q7XG4gICAgICAgIHRoaXMubGFuZ3VhZ2VzID0gb2JqLkxhbmd1YWdlO1xuICAgICAgICB0aGlzLmNvdW50cnkgPSBvYmouQ291bnRyeTtcbiAgICAgICAgdGhpcy5hd2FyZHMgPSBvYmouQXdhcmRzO1xuICAgICAgICB0aGlzLnBvc3RlciA9IG9iai5Qb3N0ZXI7XG4gICAgICAgIHRoaXMubWV0YXNjb3JlID0gb2JqLk1ldGFzY29yZTtcbiAgICAgICAgdmFyIHJhd1JhdGluZyA9IHBhcnNlRmxvYXQob2JqLmltZGJSYXRpbmcpO1xuICAgICAgICB0aGlzLnJhdGluZyA9IGlzTmFOKHJhd1JhdGluZykgPyAwIDogcmF3UmF0aW5nO1xuICAgICAgICB0aGlzLnZvdGVzID0gb2JqLmltZGJWb3RlcztcbiAgICAgICAgdGhpcy5pbWRiaWQgPSBvYmouaW1kYklEO1xuICAgICAgICB0aGlzLnR5cGUgPSBcImVwaXNvZGVcIjtcbiAgICAgICAgaWYgKG9iai5UeXBlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmICghaXNSZXF1ZXN0VHlwZShvYmouVHlwZSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKG9iai5UeXBlICsgXCIgaXMgbm90IGEgdmFsaWQgUmVxdWVzdFR5cGVcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSBvYmouVHlwZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2JqLlJhdGluZ3MgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IG9iai5SYXRpbmdzOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIHZhciByYXRpbmcgPSBfYVtfaV07XG4gICAgICAgICAgICAgICAgdGhpcy5yYXRpbmdzLnB1c2gobmV3IFJhdGluZyhyYXRpbmcuU291cmNlLCByYXRpbmcuVmFsdWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAob2JqLkRWRCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB2YXIgcmF3RHZkID0gbmV3IERhdGUob2JqLkRWRCk7XG4gICAgICAgICAgICBpZiAoaXNOYU4ocmF3RHZkLmdldFRpbWUoKSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmR2ZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZHZkID0gcmF3RHZkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuYm94b2ZmaWNlID0gb2JqLkJveE9mZmljZTtcbiAgICAgICAgdGhpcy5wcm9kdWN0aW9uID0gb2JqLlByb2R1Y3Rpb247XG4gICAgICAgIHRoaXMud2Vic2l0ZSA9IG9iai5XZWJzaXRlO1xuICAgICAgICB0aGlzLm5hbWUgPSB0aGlzLnRpdGxlO1xuICAgICAgICB0aGlzLnNlcmllcyA9IHRoaXMudHlwZSA9PT0gXCJzZXJpZXNcIjtcbiAgICAgICAgdGhpcy5pbWRidXJsID0gXCJodHRwczovL3d3dy5pbWRiLmNvbS90aXRsZS9cIiArIHRoaXMuaW1kYmlkO1xuICAgIH1cbiAgICByZXR1cm4gTW92aWU7XG59KCkpO1xuZXhwb3J0cy5Nb3ZpZSA9IE1vdmllO1xudmFyIEVwaXNvZGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhFcGlzb2RlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEVwaXNvZGUob2JqLCBzZWFzb24pIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgb2JqKSB8fCB0aGlzO1xuICAgICAgICBpZiAoc2Vhc29uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIF90aGlzLnNlYXNvbiA9IHNlYXNvbjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIF90aGlzLnNlYXNvbiA9IHBhcnNlSW50KG9iai5TZWFzb24sIDEwKTtcbiAgICAgICAgICAgIGlmIChpc05hTihfdGhpcy5zZWFzb24pKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgc2Vhc29uXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIF90aGlzLnNlcmllc2lkID0gb2JqLnNlcmllc0lEO1xuICAgICAgICBpZiAoXCJFcGlzb2RlXCIgaW4gb2JqKSB7XG4gICAgICAgICAgICBfdGhpcy5lcGlzb2RlID0gcGFyc2VJbnQob2JqLkVwaXNvZGUsIDEwKTtcbiAgICAgICAgICAgIGlmIChpc05hTihfdGhpcy5lcGlzb2RlKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIGVwaXNvZGVcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBfdGhpcy5lcGlzb2RlID0gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBFcGlzb2RlO1xufShNb3ZpZSkpO1xuZXhwb3J0cy5FcGlzb2RlID0gRXBpc29kZTtcbnZhciBUVlNob3cgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhUVlNob3csIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVFZTaG93KG9iaiwgb3B0cykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBvYmopIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLl9lcGlzb2RlcyA9IFtdO1xuICAgICAgICB2YXIgeWVhcnMgPSBfdGhpcy5feWVhckRhdGEuc3BsaXQoXCItXCIpO1xuICAgICAgICBfdGhpcy5zdGFydF95ZWFyID0gcGFyc2VJbnQoeWVhcnNbMF0sIDEwKTtcbiAgICAgICAgX3RoaXMuZW5kX3llYXIgPSBwYXJzZUludCh5ZWFyc1sxXSwgMTApID8gcGFyc2VJbnQoeWVhcnNbMV0sIDEwKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgX3RoaXMudG90YWxzZWFzb25zID0gcGFyc2VJbnQob2JqLnRvdGFsU2Vhc29ucywgMTApO1xuICAgICAgICBfdGhpcy5vcHRzID0gb3B0cztcbiAgICAgICAgaWYgKG9wdHMuYmFzZVVSTCAmJiB0eXBlb2Ygb3B0cy5iYXNlVVJMID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBvcHRzLmJhc2VVUkwgPSBuZXcgVVJMKG9wdHMuYmFzZVVSTCk7XG4gICAgICAgICAgICBfdGhpcy5iYXNlVVJMID0gb3B0cy5iYXNlVVJMO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9wdHMuYmFzZVVSTCAmJiBvcHRzLmJhc2VVUkwgaW5zdGFuY2VvZiBVUkwpIHtcbiAgICAgICAgICAgIF90aGlzLmJhc2VVUkwgPSBvcHRzLmJhc2VVUkw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBfdGhpcy5iYXNlVVJMID0gb21kYmFwaTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFRWU2hvdy5wcm90b3R5cGUuZXBpc29kZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0aGlzLl9lcGlzb2Rlcy5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5fZXBpc29kZXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm9wdHMuYXBpS2V5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBJbWRiRXJyb3IoXCJNaXNzaW5nIGFwaSBrZXkgaW4gb3B0c1wiKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZnVuY3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPD0gdGhpcy50b3RhbHNlYXNvbnM7IGkrKykge1xuICAgICAgICAgICAgdmFyIHFzXzEgPSBuZXcgdXJsX3NlYXJjaF9wYXJhbXNfMS5kZWZhdWx0KHtcbiAgICAgICAgICAgICAgICBTZWFzb246IFN0cmluZyhpKSxcbiAgICAgICAgICAgICAgICBhcGlrZXk6IHRoaXMub3B0cy5hcGlLZXksXG4gICAgICAgICAgICAgICAgaTogdGhpcy5pbWRiaWQsXG4gICAgICAgICAgICAgICAgcjogXCJqc29uXCIsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciByZXFvcHRzID0ge1xuICAgICAgICAgICAgICAgIHNlYXJjaFBhcmFtczogcXNfMSxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgdGltZW91dDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIHByZWZpeFVybDogdGhpcy5iYXNlVVJMLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdHMudGltZW91dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmVxb3B0cy50aW1lb3V0ID0gdGhpcy5vcHRzLnRpbWVvdXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jcy5wdXNoKGt5X3VuaXZlcnNhbF8xLmRlZmF1bHQoXCJcIiwgcmVxb3B0cykuanNvbigpKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcHJvbSA9IFByb21pc2UuYWxsKGZ1bmNzKVxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICAgICAgaWYgKGludGVyZmFjZXNfMS5hc3NlcnRFcGlzb2RlU2Vhc29uUmVzcG9uc2UocmVzdWx0KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgVHlwZUVycm9yKFwiSW52YWxpZCByZXNwb25zZSBmcm9tIHNlcnZlclwiKSk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoZXBEYXRhKSB7XG4gICAgICAgICAgICB2YXIgZXBzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIGVwRGF0YV8xID0gZXBEYXRhOyBfaSA8IGVwRGF0YV8xLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIHZhciBkYXR1bSA9IGVwRGF0YV8xW19pXTtcbiAgICAgICAgICAgICAgICBpZiAoaW50ZXJmYWNlc18xLmlzRXJyb3IoZGF0dW0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbWRiRXJyb3IoZGF0dW0uRXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgc2Vhc29uID0gcGFyc2VJbnQoZGF0dW0uU2Vhc29uLCAxMCk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2EgPSAwLCBfYiA9IGRhdHVtLkVwaXNvZGVzOyBfYSA8IF9iLmxlbmd0aDsgX2ErKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZXAgPSBfYltfYV07XG4gICAgICAgICAgICAgICAgICAgIGVwcy5wdXNoKG5ldyBFcGlzb2RlKGVwLCBzZWFzb24pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdGhpcy5fZXBpc29kZXMgPSBlcHM7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGVwcyk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcHJvbTtcbiAgICB9O1xuICAgIHJldHVybiBUVlNob3c7XG59KE1vdmllKSk7XG5leHBvcnRzLlRWU2hvdyA9IFRWU2hvdztcbnZhciBHYW1lID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoR2FtZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBHYW1lKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBHYW1lO1xufShNb3ZpZSkpO1xuZXhwb3J0cy5HYW1lID0gR2FtZTtcbnZhciBTZWFyY2hSZXN1bHQgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNlYXJjaFJlc3VsdChvYmopIHtcbiAgICAgICAgdGhpcy50aXRsZSA9IG9iai5UaXRsZTtcbiAgICAgICAgdGhpcy55ZWFyID0gcGFyc2VJbnQob2JqLlllYXIsIDEwKTtcbiAgICAgICAgdGhpcy5pbWRiaWQgPSBvYmouaW1kYklEO1xuICAgICAgICBpZiAoIWlzUmVxdWVzdFR5cGUob2JqLlR5cGUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKG9iai5UeXBlICsgXCIgaXMgbm90IGEgdmFsaWQgUmVxdWVzdFR5cGVcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50eXBlID0gb2JqLlR5cGU7XG4gICAgICAgIHRoaXMucG9zdGVyID0gb2JqLlBvc3RlcjtcbiAgICAgICAgdGhpcy5uYW1lID0gdGhpcy50aXRsZTtcbiAgICB9XG4gICAgcmV0dXJuIFNlYXJjaFJlc3VsdDtcbn0oKSk7XG5leHBvcnRzLlNlYXJjaFJlc3VsdCA9IFNlYXJjaFJlc3VsdDtcbnZhciBTZWFyY2hSZXN1bHRzID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTZWFyY2hSZXN1bHRzKG9iaiwgcGFnZSwgb3B0cywgcmVxKSB7XG4gICAgICAgIHRoaXMucmVzdWx0cyA9IFtdO1xuICAgICAgICB0aGlzLnBhZ2UgPSBwYWdlO1xuICAgICAgICB0aGlzLnJlcSA9IHJlcTtcbiAgICAgICAgdGhpcy5vcHRzID0gb3B0cztcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IG9iai5TZWFyY2g7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gX2FbX2ldO1xuICAgICAgICAgICAgdGhpcy5yZXN1bHRzLnB1c2gobmV3IFNlYXJjaFJlc3VsdChyZXN1bHQpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRvdGFscmVzdWx0cyA9IHBhcnNlSW50KG9iai50b3RhbFJlc3VsdHMsIDEwKTtcbiAgICB9XG4gICAgU2VhcmNoUmVzdWx0cy5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHNlYXJjaCh0aGlzLnJlcSwgdGhpcy5vcHRzLCB0aGlzLnBhZ2UgKyAxKTtcbiAgICB9O1xuICAgIHJldHVybiBTZWFyY2hSZXN1bHRzO1xufSgpKTtcbmV4cG9ydHMuU2VhcmNoUmVzdWx0cyA9IFNlYXJjaFJlc3VsdHM7XG52YXIgSW1kYkVycm9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBJbWRiRXJyb3IobWVzc2FnZSkge1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgICAgICB0aGlzLm5hbWUgPSBcImltZGIgYXBpIGVycm9yXCI7XG4gICAgfVxuICAgIHJldHVybiBJbWRiRXJyb3I7XG59KCkpO1xuZXhwb3J0cy5JbWRiRXJyb3IgPSBJbWRiRXJyb3I7XG5mdW5jdGlvbiBnZXQocmVxLCBvcHRzKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIG5ldyBDbGllbnQob3B0cykuZ2V0KHJlcSk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlKTtcbiAgICB9XG59XG5leHBvcnRzLmdldCA9IGdldDtcbmZ1bmN0aW9uIHNlYXJjaChyZXEsIG9wdHMsIHBhZ2UpIHtcbiAgICByZXR1cm4gbmV3IENsaWVudChvcHRzKS5zZWFyY2gocmVxLCBwYWdlKTtcbn1cbmV4cG9ydHMuc2VhcmNoID0gc2VhcmNoO1xudmFyIENsaWVudCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ2xpZW50KG9wdHMpIHtcbiAgICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob3B0cywgXCJhcGlLZXlcIikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBJbWRiRXJyb3IoXCJNaXNzaW5nIGFwaSBrZXkgaW4gb3B0c1wiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9wdHMgPSBvcHRzO1xuICAgICAgICBpZiAob3B0cy5iYXNlVVJMICYmIHR5cGVvZiBvcHRzLmJhc2VVUkwgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIG9wdHMuYmFzZVVSTCA9IG5ldyBVUkwob3B0cy5iYXNlVVJMKTtcbiAgICAgICAgICAgIHRoaXMuYmFzZVVSTCA9IG9wdHMuYmFzZVVSTDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvcHRzLmJhc2VVUkwgJiYgb3B0cy5iYXNlVVJMIGluc3RhbmNlb2YgVVJMKSB7XG4gICAgICAgICAgICB0aGlzLmJhc2VVUkwgPSBvcHRzLmJhc2VVUkw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmJhc2VVUkwgPSBvbWRiYXBpO1xuICAgICAgICB9XG4gICAgfVxuICAgIENsaWVudC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKHJlcSwgb3B0cykge1xuICAgICAgICB2YXIgbWVyZ2VkT3B0cyA9IHRoaXMubWVyZ2VPcHRzKG9wdHMpO1xuICAgICAgICBpZiAobWVyZ2VkT3B0cy5hcGlLZXkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEltZGJFcnJvcihcIk1pc3NpbmcgYXBpIGtleSBpbiBvcHRzXCIpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBxcyA9IG5ldyB1cmxfc2VhcmNoX3BhcmFtc18xLmRlZmF1bHQoe1xuICAgICAgICAgICAgYXBpa2V5OiBtZXJnZWRPcHRzLmFwaUtleSxcbiAgICAgICAgICAgIHBsb3Q6IHJlcS5zaG9ydF9wbG90ID8gXCJzaG9ydFwiIDogXCJmdWxsXCIsXG4gICAgICAgICAgICByOiBcImpzb25cIixcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChyZXEueWVhciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBxcy5hcHBlbmQoXCJ5XCIsIFN0cmluZyhyZXEueWVhcikpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXEubmFtZSkge1xuICAgICAgICAgICAgcXMuYXBwZW5kKFwidFwiLCByZXEubmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocmVxLmlkKSB7XG4gICAgICAgICAgICBxcy5hcHBlbmQoXCJpXCIsIHJlcS5pZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEltZGJFcnJvcihcIk1pc3Npbmcgb25lIG9mIHJlcS5pZCBvciByZXEubmFtZVwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlcW9wdHMgPSB7XG4gICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2VhcmNoUGFyYW1zOiBxcyxcbiAgICAgICAgICAgIHRpbWVvdXQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHByZWZpeFVybDogdGhpcy5iYXNlVVJMLFxuICAgICAgICB9O1xuICAgICAgICBpZiAoXCJ0aW1lb3V0XCIgaW4gbWVyZ2VkT3B0cykge1xuICAgICAgICAgICAgcmVxb3B0cy50aW1lb3V0ID0gbWVyZ2VkT3B0cy50aW1lb3V0O1xuICAgICAgICB9XG4gICAgICAgIHZhciBwcm9tID0ga3lfdW5pdmVyc2FsXzEuZGVmYXVsdChcIlwiLCByZXFvcHRzKVxuICAgICAgICAgICAgLmpzb24oKVxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICBpZiAoaW50ZXJmYWNlc18xLmFzc2VydEdldFJlc3BvbnNlKHJlc3BvbnNlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocmVzcG9uc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIHJlc3BvbnNlIGZyb20gc2VydmVyXCIpKTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICB2YXIgcmV0O1xuICAgICAgICAgICAgaWYgKGludGVyZmFjZXNfMS5pc0Vycm9yKGRhdGEpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEltZGJFcnJvcihkYXRhLkVycm9yICsgXCI6IFwiICsgKHJlcS5uYW1lID8gcmVxLm5hbWUgOiByZXEuaWQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpbnRlcmZhY2VzXzEuaXNNb3ZpZShkYXRhKSkge1xuICAgICAgICAgICAgICAgIHJldCA9IG5ldyBNb3ZpZShkYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGludGVyZmFjZXNfMS5pc0dhbWUoZGF0YSkpIHtcbiAgICAgICAgICAgICAgICByZXQgPSBuZXcgR2FtZShkYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGludGVyZmFjZXNfMS5pc1R2c2hvdyhkYXRhKSkge1xuICAgICAgICAgICAgICAgIHJldCA9IG5ldyBUVlNob3coZGF0YSwgbWVyZ2VkT3B0cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpbnRlcmZhY2VzXzEuaXNFcGlzb2RlKGRhdGEpKSB7XG4gICAgICAgICAgICAgICAgcmV0ID0gbmV3IEVwaXNvZGUoZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSW1kYkVycm9yKFwidHlwZTogJ1wiICsgZGF0YS5UeXBlICsgXCInIGlzIG5vdCB2YWxpZFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocmV0KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBwcm9tO1xuICAgIH07XG4gICAgQ2xpZW50LnByb3RvdHlwZS5zZWFyY2ggPSBmdW5jdGlvbiAocmVxLCBwYWdlLCBvcHRzKSB7XG4gICAgICAgIHZhciBtZXJnZWRPcHRzID0gdGhpcy5tZXJnZU9wdHMob3B0cyk7XG4gICAgICAgIGlmIChwYWdlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHBhZ2UgPSAxO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXJnZWRPcHRzLmFwaUtleSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgSW1kYkVycm9yKFwiTWlzc2luZyBhcGkga2V5IGluIG9wdHNcIik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHFzID0gcmVxdG9xdWVyeW9iaihyZXEsIG1lcmdlZE9wdHMuYXBpS2V5LCBwYWdlKTtcbiAgICAgICAgdmFyIHJlcW9wdHMgPSB7XG4gICAgICAgICAgICBzZWFyY2hQYXJhbXM6IHFzLFxuICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRpbWVvdXQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHByZWZpeFVybDogdGhpcy5iYXNlVVJMLFxuICAgICAgICB9O1xuICAgICAgICBpZiAobWVyZ2VkT3B0cy50aW1lb3V0KSB7XG4gICAgICAgICAgICByZXFvcHRzLnRpbWVvdXQgPSBtZXJnZWRPcHRzLnRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHByb20gPSBreV91bml2ZXJzYWxfMS5kZWZhdWx0KFwiXCIsIHJlcW9wdHMpXG4gICAgICAgICAgICAuanNvbigpXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgICAgICAgIGlmIChpbnRlcmZhY2VzXzEuYXNzZXJ0U2VhcmNoUmVzcG9uc2UocmVzcG9uc2UpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyZXNwb25zZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IFR5cGVFcnJvcihcIkludmFsaWQgcmVzcG9uc2UgZnJvbSBzZXJ2ZXJcIikpO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgIGlmIChpbnRlcmZhY2VzXzEuaXNFcnJvcihkYXRhKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbWRiRXJyb3IoZGF0YS5FcnJvciArIFwiOiBcIiArIHJlcS5uYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYWdlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBwYWdlID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobmV3IFNlYXJjaFJlc3VsdHMoZGF0YSwgcGFnZSwgbWVyZ2VkT3B0cywgcmVxKSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcHJvbTtcbiAgICB9O1xuICAgIENsaWVudC5wcm90b3R5cGUubWVyZ2VPcHRzID0gZnVuY3Rpb24gKG9wdHMpIHtcbiAgICAgICAgaWYgKG9wdHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIF9fYXNzaWduKF9fYXNzaWduKHt9LCB0aGlzLm9wdHMpLCBvcHRzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX19hc3NpZ24oe30sIHRoaXMub3B0cyk7XG4gICAgfTtcbiAgICByZXR1cm4gQ2xpZW50O1xufSgpKTtcbmV4cG9ydHMuQ2xpZW50ID0gQ2xpZW50O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW1kYi5qcy5tYXAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/imdb-api/lib/imdb.js\n");

/***/ }),

/***/ "./node_modules/imdb-api/lib/interfaces.js":
/*!*************************************************!*\
  !*** ./node_modules/imdb-api/lib/interfaces.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.assertSearchResponse = exports.assertGetResponse = exports.assertEpisodeSeasonResponse = exports.isGame = exports.isEpisode = exports.isMovie = exports.isTvshow = exports.isError = void 0;\nfunction isError(response) {\n    return response.Response === \"False\";\n}\nexports.isError = isError;\nfunction isTvshow(response) {\n    return response.Type === \"series\";\n}\nexports.isTvshow = isTvshow;\nfunction isMovie(response) {\n    return response.Type === \"movie\";\n}\nexports.isMovie = isMovie;\nfunction isEpisode(response) {\n    return response.Type === \"episode\";\n}\nexports.isEpisode = isEpisode;\nfunction isGame(response) {\n    return response.Type === \"game\";\n}\nexports.isGame = isGame;\nfunction assertEpisodeSeasonResponse(response) {\n    if (!Array.isArray(response)) {\n        return false;\n    }\n    for (var _i = 0, response_1 = response; _i < response_1.length; _i++) {\n        var res = response_1[_i];\n        if (typeof res !== \"object\") {\n            return false;\n        }\n        if (\"Response\" in res) {\n            if (res.Response === \"False\") {\n                return true;\n            }\n            if (\"Season\" in res && \"totalSeasons\" in res) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\nexports.assertEpisodeSeasonResponse = assertEpisodeSeasonResponse;\nfunction assertGetResponse(response) {\n    if (typeof response !== \"object\") {\n        return false;\n    }\n    var res = response;\n    if (res === null) {\n        return false;\n    }\n    if (\"Response\" in res) {\n        return true;\n    }\n    return false;\n}\nexports.assertGetResponse = assertGetResponse;\nfunction assertSearchResponse(response) {\n    if (typeof response !== \"object\") {\n        return false;\n    }\n    var res = response;\n    if (res === null) {\n        return false;\n    }\n    if (\"Response\" in res) {\n        if (res.Response === \"False\") {\n            return true;\n        }\n    }\n    if (\"Search\" in res) {\n        return true;\n    }\n    return false;\n}\nexports.assertSearchResponse = assertSearchResponse;\n//# sourceMappingURL=interfaces.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2ltZGItYXBpL2xpYi9pbnRlcmZhY2VzLmpzPzZkMGYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyx3QkFBd0I7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9pbWRiLWFwaS9saWIvaW50ZXJmYWNlcy5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5hc3NlcnRTZWFyY2hSZXNwb25zZSA9IGV4cG9ydHMuYXNzZXJ0R2V0UmVzcG9uc2UgPSBleHBvcnRzLmFzc2VydEVwaXNvZGVTZWFzb25SZXNwb25zZSA9IGV4cG9ydHMuaXNHYW1lID0gZXhwb3J0cy5pc0VwaXNvZGUgPSBleHBvcnRzLmlzTW92aWUgPSBleHBvcnRzLmlzVHZzaG93ID0gZXhwb3J0cy5pc0Vycm9yID0gdm9pZCAwO1xuZnVuY3Rpb24gaXNFcnJvcihyZXNwb25zZSkge1xuICAgIHJldHVybiByZXNwb25zZS5SZXNwb25zZSA9PT0gXCJGYWxzZVwiO1xufVxuZXhwb3J0cy5pc0Vycm9yID0gaXNFcnJvcjtcbmZ1bmN0aW9uIGlzVHZzaG93KHJlc3BvbnNlKSB7XG4gICAgcmV0dXJuIHJlc3BvbnNlLlR5cGUgPT09IFwic2VyaWVzXCI7XG59XG5leHBvcnRzLmlzVHZzaG93ID0gaXNUdnNob3c7XG5mdW5jdGlvbiBpc01vdmllKHJlc3BvbnNlKSB7XG4gICAgcmV0dXJuIHJlc3BvbnNlLlR5cGUgPT09IFwibW92aWVcIjtcbn1cbmV4cG9ydHMuaXNNb3ZpZSA9IGlzTW92aWU7XG5mdW5jdGlvbiBpc0VwaXNvZGUocmVzcG9uc2UpIHtcbiAgICByZXR1cm4gcmVzcG9uc2UuVHlwZSA9PT0gXCJlcGlzb2RlXCI7XG59XG5leHBvcnRzLmlzRXBpc29kZSA9IGlzRXBpc29kZTtcbmZ1bmN0aW9uIGlzR2FtZShyZXNwb25zZSkge1xuICAgIHJldHVybiByZXNwb25zZS5UeXBlID09PSBcImdhbWVcIjtcbn1cbmV4cG9ydHMuaXNHYW1lID0gaXNHYW1lO1xuZnVuY3Rpb24gYXNzZXJ0RXBpc29kZVNlYXNvblJlc3BvbnNlKHJlc3BvbnNlKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHJlc3BvbnNlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZvciAodmFyIF9pID0gMCwgcmVzcG9uc2VfMSA9IHJlc3BvbnNlOyBfaSA8IHJlc3BvbnNlXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciByZXMgPSByZXNwb25zZV8xW19pXTtcbiAgICAgICAgaWYgKHR5cGVvZiByZXMgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoXCJSZXNwb25zZVwiIGluIHJlcykge1xuICAgICAgICAgICAgaWYgKHJlcy5SZXNwb25zZSA9PT0gXCJGYWxzZVwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoXCJTZWFzb25cIiBpbiByZXMgJiYgXCJ0b3RhbFNlYXNvbnNcIiBpbiByZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5leHBvcnRzLmFzc2VydEVwaXNvZGVTZWFzb25SZXNwb25zZSA9IGFzc2VydEVwaXNvZGVTZWFzb25SZXNwb25zZTtcbmZ1bmN0aW9uIGFzc2VydEdldFJlc3BvbnNlKHJlc3BvbnNlKSB7XG4gICAgaWYgKHR5cGVvZiByZXNwb25zZSAhPT0gXCJvYmplY3RcIikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHZhciByZXMgPSByZXNwb25zZTtcbiAgICBpZiAocmVzID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKFwiUmVzcG9uc2VcIiBpbiByZXMpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmV4cG9ydHMuYXNzZXJ0R2V0UmVzcG9uc2UgPSBhc3NlcnRHZXRSZXNwb25zZTtcbmZ1bmN0aW9uIGFzc2VydFNlYXJjaFJlc3BvbnNlKHJlc3BvbnNlKSB7XG4gICAgaWYgKHR5cGVvZiByZXNwb25zZSAhPT0gXCJvYmplY3RcIikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHZhciByZXMgPSByZXNwb25zZTtcbiAgICBpZiAocmVzID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKFwiUmVzcG9uc2VcIiBpbiByZXMpIHtcbiAgICAgICAgaWYgKHJlcy5SZXNwb25zZSA9PT0gXCJGYWxzZVwiKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoXCJTZWFyY2hcIiBpbiByZXMpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmV4cG9ydHMuYXNzZXJ0U2VhcmNoUmVzcG9uc2UgPSBhc3NlcnRTZWFyY2hSZXNwb25zZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWludGVyZmFjZXMuanMubWFwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/imdb-api/lib/interfaces.js\n");

/***/ }),

/***/ "./node_modules/ky-universal/browser.js":
/*!**********************************************!*\
  !*** ./node_modules/ky-universal/browser.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var ky__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ky */ \"./node_modules/ky/index.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return ky__WEBPACK_IMPORTED_MODULE_0__[\"default\"]; });\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2t5LXVuaXZlcnNhbC9icm93c2VyLmpzP2RmZmEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBMkIiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMva3ktdW5pdmVyc2FsL2Jyb3dzZXIuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQge2RlZmF1bHR9IGZyb20gJ2t5JztcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/ky-universal/browser.js\n");

/***/ }),

/***/ "./node_modules/ky/index.js":
/*!**********************************!*\
  !*** ./node_modules/ky/index.js ***!
  \**********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(global) {/*! MIT License Â© Sindre Sorhus */\n\nconst globals = {};\n\nconst getGlobal = property => {\n\t/* istanbul ignore next */\n\tif (typeof self !== 'undefined' && self && property in self) {\n\t\treturn self;\n\t}\n\n\t/* istanbul ignore next */\n\tif (typeof window !== 'undefined' && window && property in window) {\n\t\treturn window;\n\t}\n\n\tif (typeof global !== 'undefined' && global && property in global) {\n\t\treturn global;\n\t}\n\n\t/* istanbul ignore next */\n\tif (typeof globalThis !== 'undefined' && globalThis) {\n\t\treturn globalThis;\n\t}\n};\n\nconst globalProperties = [\n\t'Headers',\n\t'Request',\n\t'Response',\n\t'ReadableStream',\n\t'fetch',\n\t'AbortController',\n\t'FormData'\n];\n\nfor (const property of globalProperties) {\n\tObject.defineProperty(globals, property, {\n\t\tget() {\n\t\t\tconst globalObject = getGlobal(property);\n\t\t\tconst value = globalObject && globalObject[property];\n\t\t\treturn typeof value === 'function' ? value.bind(globalObject) : value;\n\t\t}\n\t});\n}\n\nconst isObject = value => value !== null && typeof value === 'object';\nconst supportsAbortController = typeof globals.AbortController === 'function';\nconst supportsStreams = typeof globals.ReadableStream === 'function';\nconst supportsFormData = typeof globals.FormData === 'function';\n\nconst mergeHeaders = (source1, source2) => {\n\tconst result = new globals.Headers(source1 || {});\n\tconst isHeadersInstance = source2 instanceof globals.Headers;\n\tconst source = new globals.Headers(source2 || {});\n\n\tfor (const [key, value] of source) {\n\t\tif ((isHeadersInstance && value === 'undefined') || value === undefined) {\n\t\t\tresult.delete(key);\n\t\t} else {\n\t\t\tresult.set(key, value);\n\t\t}\n\t}\n\n\treturn result;\n};\n\nconst deepMerge = (...sources) => {\n\tlet returnValue = {};\n\tlet headers = {};\n\n\tfor (const source of sources) {\n\t\tif (Array.isArray(source)) {\n\t\t\tif (!(Array.isArray(returnValue))) {\n\t\t\t\treturnValue = [];\n\t\t\t}\n\n\t\t\treturnValue = [...returnValue, ...source];\n\t\t} else if (isObject(source)) {\n\t\t\tfor (let [key, value] of Object.entries(source)) {\n\t\t\t\tif (isObject(value) && Reflect.has(returnValue, key)) {\n\t\t\t\t\tvalue = deepMerge(returnValue[key], value);\n\t\t\t\t}\n\n\t\t\t\treturnValue = {...returnValue, [key]: value};\n\t\t\t}\n\n\t\t\tif (isObject(source.headers)) {\n\t\t\t\theaders = mergeHeaders(headers, source.headers);\n\t\t\t}\n\t\t}\n\n\t\treturnValue.headers = headers;\n\t}\n\n\treturn returnValue;\n};\n\nconst requestMethods = [\n\t'get',\n\t'post',\n\t'put',\n\t'patch',\n\t'head',\n\t'delete'\n];\n\nconst responseTypes = {\n\tjson: 'application/json',\n\ttext: 'text/*',\n\tformData: 'multipart/form-data',\n\tarrayBuffer: '*/*',\n\tblob: '*/*'\n};\n\nconst retryMethods = [\n\t'get',\n\t'put',\n\t'head',\n\t'delete',\n\t'options',\n\t'trace'\n];\n\nconst retryStatusCodes = [\n\t408,\n\t413,\n\t429,\n\t500,\n\t502,\n\t503,\n\t504\n];\n\nconst retryAfterStatusCodes = [\n\t413,\n\t429,\n\t503\n];\n\nconst stop = Symbol('stop');\n\nclass HTTPError extends Error {\n\tconstructor(response) {\n\t\t// Set the message to the status text, such as Unauthorized,\n\t\t// with some fallbacks. This message should never be undefined.\n\t\tsuper(\n\t\t\tresponse.statusText ||\n\t\t\tString(\n\t\t\t\t(response.status === 0 || response.status) ?\n\t\t\t\t\tresponse.status : 'Unknown response error'\n\t\t\t)\n\t\t);\n\t\tthis.name = 'HTTPError';\n\t\tthis.response = response;\n\t}\n}\n\nclass TimeoutError extends Error {\n\tconstructor(request) {\n\t\tsuper('Request timed out');\n\t\tthis.name = 'TimeoutError';\n\t\tthis.request = request;\n\t}\n}\n\nconst delay = ms => new Promise(resolve => setTimeout(resolve, ms));\n\n// `Promise.race()` workaround (#91)\nconst timeout = (request, abortController, options) =>\n\tnew Promise((resolve, reject) => {\n\t\tconst timeoutID = setTimeout(() => {\n\t\t\tif (abortController) {\n\t\t\t\tabortController.abort();\n\t\t\t}\n\n\t\t\treject(new TimeoutError(request));\n\t\t}, options.timeout);\n\n\t\t/* eslint-disable promise/prefer-await-to-then */\n\t\toptions.fetch(request)\n\t\t\t.then(resolve)\n\t\t\t.catch(reject)\n\t\t\t.then(() => {\n\t\t\t\tclearTimeout(timeoutID);\n\t\t\t});\n\t\t/* eslint-enable promise/prefer-await-to-then */\n\t});\n\nconst normalizeRequestMethod = input => requestMethods.includes(input) ? input.toUpperCase() : input;\n\nconst defaultRetryOptions = {\n\tlimit: 2,\n\tmethods: retryMethods,\n\tstatusCodes: retryStatusCodes,\n\tafterStatusCodes: retryAfterStatusCodes\n};\n\nconst normalizeRetryOptions = (retry = {}) => {\n\tif (typeof retry === 'number') {\n\t\treturn {\n\t\t\t...defaultRetryOptions,\n\t\t\tlimit: retry\n\t\t};\n\t}\n\n\tif (retry.methods && !Array.isArray(retry.methods)) {\n\t\tthrow new Error('retry.methods must be an array');\n\t}\n\n\tif (retry.statusCodes && !Array.isArray(retry.statusCodes)) {\n\t\tthrow new Error('retry.statusCodes must be an array');\n\t}\n\n\treturn {\n\t\t...defaultRetryOptions,\n\t\t...retry,\n\t\tafterStatusCodes: retryAfterStatusCodes\n\t};\n};\n\n// The maximum value of a 32bit int (see issue #117)\nconst maxSafeTimeout = 2147483647;\n\nclass Ky {\n\tconstructor(input, options = {}) {\n\t\tthis._retryCount = 0;\n\t\tthis._input = input;\n\t\tthis._options = {\n\t\t\t// TODO: credentials can be removed when the spec change is implemented in all browsers. Context: https://www.chromestatus.com/feature/4539473312350208\n\t\t\tcredentials: this._input.credentials || 'same-origin',\n\t\t\t...options,\n\t\t\theaders: mergeHeaders(this._input.headers, options.headers),\n\t\t\thooks: deepMerge({\n\t\t\t\tbeforeRequest: [],\n\t\t\t\tbeforeRetry: [],\n\t\t\t\tafterResponse: []\n\t\t\t}, options.hooks),\n\t\t\tmethod: normalizeRequestMethod(options.method || this._input.method),\n\t\t\tprefixUrl: String(options.prefixUrl || ''),\n\t\t\tretry: normalizeRetryOptions(options.retry),\n\t\t\tthrowHttpErrors: options.throwHttpErrors !== false,\n\t\t\ttimeout: typeof options.timeout === 'undefined' ? 10000 : options.timeout,\n\t\t\tfetch: options.fetch || globals.fetch\n\t\t};\n\n\t\tif (typeof this._input !== 'string' && !(this._input instanceof URL || this._input instanceof globals.Request)) {\n\t\t\tthrow new TypeError('`input` must be a string, URL, or Request');\n\t\t}\n\n\t\tif (this._options.prefixUrl && typeof this._input === 'string') {\n\t\t\tif (this._input.startsWith('/')) {\n\t\t\t\tthrow new Error('`input` must not begin with a slash when using `prefixUrl`');\n\t\t\t}\n\n\t\t\tif (!this._options.prefixUrl.endsWith('/')) {\n\t\t\t\tthis._options.prefixUrl += '/';\n\t\t\t}\n\n\t\t\tthis._input = this._options.prefixUrl + this._input;\n\t\t}\n\n\t\tif (supportsAbortController) {\n\t\t\tthis.abortController = new globals.AbortController();\n\t\t\tif (this._options.signal) {\n\t\t\t\tthis._options.signal.addEventListener('abort', () => {\n\t\t\t\t\tthis.abortController.abort();\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tthis._options.signal = this.abortController.signal;\n\t\t}\n\n\t\tthis.request = new globals.Request(this._input, this._options);\n\n\t\tif (this._options.searchParams) {\n\t\t\tconst searchParams = '?' + new URLSearchParams(this._options.searchParams).toString();\n\t\t\tconst url = this.request.url.replace(/(?:\\?.*?)?(?=#|$)/, searchParams);\n\n\t\t\t// To provide correct form boundary, Content-Type header should be deleted each time when new Request instantiated from another one\n\t\t\tif (((supportsFormData && this._options.body instanceof globals.FormData) || this._options.body instanceof URLSearchParams) && !(this._options.headers && this._options.headers['content-type'])) {\n\t\t\t\tthis.request.headers.delete('content-type');\n\t\t\t}\n\n\t\t\tthis.request = new globals.Request(new globals.Request(url, this.request), this._options);\n\t\t}\n\n\t\tif (this._options.json !== undefined) {\n\t\t\tthis._options.body = JSON.stringify(this._options.json);\n\t\t\tthis.request.headers.set('content-type', 'application/json');\n\t\t\tthis.request = new globals.Request(this.request, {body: this._options.body});\n\t\t}\n\n\t\tconst fn = async () => {\n\t\t\tif (this._options.timeout > maxSafeTimeout) {\n\t\t\t\tthrow new RangeError(`The \\`timeout\\` option cannot be greater than ${maxSafeTimeout}`);\n\t\t\t}\n\n\t\t\tawait delay(1);\n\t\t\tlet response = await this._fetch();\n\n\t\t\tfor (const hook of this._options.hooks.afterResponse) {\n\t\t\t\t// eslint-disable-next-line no-await-in-loop\n\t\t\t\tconst modifiedResponse = await hook(\n\t\t\t\t\tthis.request,\n\t\t\t\t\tthis._options,\n\t\t\t\t\tthis._decorateResponse(response.clone())\n\t\t\t\t);\n\n\t\t\t\tif (modifiedResponse instanceof globals.Response) {\n\t\t\t\t\tresponse = modifiedResponse;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis._decorateResponse(response);\n\n\t\t\tif (!response.ok && this._options.throwHttpErrors) {\n\t\t\t\tthrow new HTTPError(response);\n\t\t\t}\n\n\t\t\t// If `onDownloadProgress` is passed, it uses the stream API internally\n\t\t\t/* istanbul ignore next */\n\t\t\tif (this._options.onDownloadProgress) {\n\t\t\t\tif (typeof this._options.onDownloadProgress !== 'function') {\n\t\t\t\t\tthrow new TypeError('The `onDownloadProgress` option must be a function');\n\t\t\t\t}\n\n\t\t\t\tif (!supportsStreams) {\n\t\t\t\t\tthrow new Error('Streams are not supported in your environment. `ReadableStream` is missing.');\n\t\t\t\t}\n\n\t\t\t\treturn this._stream(response.clone(), this._options.onDownloadProgress);\n\t\t\t}\n\n\t\t\treturn response;\n\t\t};\n\n\t\tconst isRetriableMethod = this._options.retry.methods.includes(this.request.method.toLowerCase());\n\t\tconst result = isRetriableMethod ? this._retry(fn) : fn();\n\n\t\tfor (const [type, mimeType] of Object.entries(responseTypes)) {\n\t\t\tresult[type] = async () => {\n\t\t\t\tthis.request.headers.set('accept', this.request.headers.get('accept') || mimeType);\n\n\t\t\t\tconst response = (await result).clone();\n\n\t\t\t\tif (type === 'json') {\n\t\t\t\t\tif (response.status === 204) {\n\t\t\t\t\t\treturn '';\n\t\t\t\t\t}\n\n\t\t\t\t\tif (options.parseJson) {\n\t\t\t\t\t\treturn options.parseJson(await response.text());\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn response[type]();\n\t\t\t};\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t_calculateRetryDelay(error) {\n\t\tthis._retryCount++;\n\n\t\tif (this._retryCount < this._options.retry.limit && !(error instanceof TimeoutError)) {\n\t\t\tif (error instanceof HTTPError) {\n\t\t\t\tif (!this._options.retry.statusCodes.includes(error.response.status)) {\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\n\t\t\t\tconst retryAfter = error.response.headers.get('Retry-After');\n\t\t\t\tif (retryAfter && this._options.retry.afterStatusCodes.includes(error.response.status)) {\n\t\t\t\t\tlet after = Number(retryAfter);\n\t\t\t\t\tif (Number.isNaN(after)) {\n\t\t\t\t\t\tafter = Date.parse(retryAfter) - Date.now();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tafter *= 1000;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (typeof this._options.retry.maxRetryAfter !== 'undefined' && after > this._options.retry.maxRetryAfter) {\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn after;\n\t\t\t\t}\n\n\t\t\t\tif (error.response.status === 413) {\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst BACKOFF_FACTOR = 0.3;\n\t\t\treturn BACKOFF_FACTOR * (2 ** (this._retryCount - 1)) * 1000;\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\t_decorateResponse(response) {\n\t\tif (this._options.parseJson) {\n\t\t\tresponse.json = async () => {\n\t\t\t\treturn this._options.parseJson(await response.text());\n\t\t\t};\n\t\t}\n\n\t\treturn response;\n\t}\n\n\tasync _retry(fn) {\n\t\ttry {\n\t\t\treturn await fn();\n\t\t} catch (error) {\n\t\t\tconst ms = Math.min(this._calculateRetryDelay(error), maxSafeTimeout);\n\t\t\tif (ms !== 0 && this._retryCount > 0) {\n\t\t\t\tawait delay(ms);\n\n\t\t\t\tfor (const hook of this._options.hooks.beforeRetry) {\n\t\t\t\t\t// eslint-disable-next-line no-await-in-loop\n\t\t\t\t\tconst hookResult = await hook({\n\t\t\t\t\t\trequest: this.request,\n\t\t\t\t\t\toptions: this._options,\n\t\t\t\t\t\terror,\n\t\t\t\t\t\tretryCount: this._retryCount\n\t\t\t\t\t});\n\n\t\t\t\t\t// If `stop` is returned from the hook, the retry process is stopped\n\t\t\t\t\tif (hookResult === stop) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn this._retry(fn);\n\t\t\t}\n\n\t\t\tif (this._options.throwHttpErrors) {\n\t\t\t\tthrow error;\n\t\t\t}\n\t\t}\n\t}\n\n\tasync _fetch() {\n\t\tfor (const hook of this._options.hooks.beforeRequest) {\n\t\t\t// eslint-disable-next-line no-await-in-loop\n\t\t\tconst result = await hook(this.request, this._options);\n\n\t\t\tif (result instanceof Request) {\n\t\t\t\tthis.request = result;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (result instanceof Response) {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\n\t\tif (this._options.timeout === false) {\n\t\t\treturn this._options.fetch(this.request.clone());\n\t\t}\n\n\t\treturn timeout(this.request.clone(), this.abortController, this._options);\n\t}\n\n\t/* istanbul ignore next */\n\t_stream(response, onDownloadProgress) {\n\t\tconst totalBytes = Number(response.headers.get('content-length')) || 0;\n\t\tlet transferredBytes = 0;\n\n\t\treturn new globals.Response(\n\t\t\tnew globals.ReadableStream({\n\t\t\t\tstart(controller) {\n\t\t\t\t\tconst reader = response.body.getReader();\n\n\t\t\t\t\tif (onDownloadProgress) {\n\t\t\t\t\t\tonDownloadProgress({percent: 0, transferredBytes: 0, totalBytes}, new Uint8Array());\n\t\t\t\t\t}\n\n\t\t\t\t\tasync function read() {\n\t\t\t\t\t\tconst {done, value} = await reader.read();\n\t\t\t\t\t\tif (done) {\n\t\t\t\t\t\t\tcontroller.close();\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (onDownloadProgress) {\n\t\t\t\t\t\t\ttransferredBytes += value.byteLength;\n\t\t\t\t\t\t\tconst percent = totalBytes === 0 ? 0 : transferredBytes / totalBytes;\n\t\t\t\t\t\t\tonDownloadProgress({percent, transferredBytes, totalBytes}, value);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcontroller.enqueue(value);\n\t\t\t\t\t\tread();\n\t\t\t\t\t}\n\n\t\t\t\t\tread();\n\t\t\t\t}\n\t\t\t})\n\t\t);\n\t}\n}\n\nconst validateAndMerge = (...sources) => {\n\tfor (const source of sources) {\n\t\tif ((!isObject(source) || Array.isArray(source)) && typeof source !== 'undefined') {\n\t\t\tthrow new TypeError('The `options` argument must be an object');\n\t\t}\n\t}\n\n\treturn deepMerge({}, ...sources);\n};\n\nconst createInstance = defaults => {\n\tconst ky = (input, options) => new Ky(input, validateAndMerge(defaults, options));\n\n\tfor (const method of requestMethods) {\n\t\tky[method] = (input, options) => new Ky(input, validateAndMerge(defaults, options, {method}));\n\t}\n\n\tky.HTTPError = HTTPError;\n\tky.TimeoutError = TimeoutError;\n\tky.create = newDefaults => createInstance(validateAndMerge(newDefaults));\n\tky.extend = newDefaults => createInstance(validateAndMerge(defaults, newDefaults));\n\tky.stop = stop;\n\n\treturn ky;\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (createInstance());\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2t5L2luZGV4LmpzP2Q4MjMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBLGlEQUFpRDs7QUFFakQ7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQjtBQUNuQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQseUJBQXlCO0FBQzlFOztBQUVBO0FBQ0E7QUFDQSwwRUFBMEUsZUFBZTtBQUN6Rjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMEJBQTBCLDRDQUE0QztBQUN0RTs7QUFFQTtBQUNBLGFBQWEsWUFBWTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsc0NBQXNDO0FBQ2pFOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CO0FBQ3BCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxzRkFBc0YsT0FBTztBQUM3Rjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRWUsK0VBQWdCLEVBQUMiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMva3kvaW5kZXguanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiEgTUlUIExpY2Vuc2UgwqkgU2luZHJlIFNvcmh1cyAqL1xuXG5jb25zdCBnbG9iYWxzID0ge307XG5cbmNvbnN0IGdldEdsb2JhbCA9IHByb3BlcnR5ID0+IHtcblx0LyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cblx0aWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyAmJiBzZWxmICYmIHByb3BlcnR5IGluIHNlbGYpIHtcblx0XHRyZXR1cm4gc2VsZjtcblx0fVxuXG5cdC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5cdGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cgJiYgcHJvcGVydHkgaW4gd2luZG93KSB7XG5cdFx0cmV0dXJuIHdpbmRvdztcblx0fVxuXG5cdGlmICh0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyAmJiBnbG9iYWwgJiYgcHJvcGVydHkgaW4gZ2xvYmFsKSB7XG5cdFx0cmV0dXJuIGdsb2JhbDtcblx0fVxuXG5cdC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5cdGlmICh0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcgJiYgZ2xvYmFsVGhpcykge1xuXHRcdHJldHVybiBnbG9iYWxUaGlzO1xuXHR9XG59O1xuXG5jb25zdCBnbG9iYWxQcm9wZXJ0aWVzID0gW1xuXHQnSGVhZGVycycsXG5cdCdSZXF1ZXN0Jyxcblx0J1Jlc3BvbnNlJyxcblx0J1JlYWRhYmxlU3RyZWFtJyxcblx0J2ZldGNoJyxcblx0J0Fib3J0Q29udHJvbGxlcicsXG5cdCdGb3JtRGF0YSdcbl07XG5cbmZvciAoY29uc3QgcHJvcGVydHkgb2YgZ2xvYmFsUHJvcGVydGllcykge1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZ2xvYmFscywgcHJvcGVydHksIHtcblx0XHRnZXQoKSB7XG5cdFx0XHRjb25zdCBnbG9iYWxPYmplY3QgPSBnZXRHbG9iYWwocHJvcGVydHkpO1xuXHRcdFx0Y29uc3QgdmFsdWUgPSBnbG9iYWxPYmplY3QgJiYgZ2xvYmFsT2JqZWN0W3Byb3BlcnR5XTtcblx0XHRcdHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicgPyB2YWx1ZS5iaW5kKGdsb2JhbE9iamVjdCkgOiB2YWx1ZTtcblx0XHR9XG5cdH0pO1xufVxuXG5jb25zdCBpc09iamVjdCA9IHZhbHVlID0+IHZhbHVlICE9PSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCc7XG5jb25zdCBzdXBwb3J0c0Fib3J0Q29udHJvbGxlciA9IHR5cGVvZiBnbG9iYWxzLkFib3J0Q29udHJvbGxlciA9PT0gJ2Z1bmN0aW9uJztcbmNvbnN0IHN1cHBvcnRzU3RyZWFtcyA9IHR5cGVvZiBnbG9iYWxzLlJlYWRhYmxlU3RyZWFtID09PSAnZnVuY3Rpb24nO1xuY29uc3Qgc3VwcG9ydHNGb3JtRGF0YSA9IHR5cGVvZiBnbG9iYWxzLkZvcm1EYXRhID09PSAnZnVuY3Rpb24nO1xuXG5jb25zdCBtZXJnZUhlYWRlcnMgPSAoc291cmNlMSwgc291cmNlMikgPT4ge1xuXHRjb25zdCByZXN1bHQgPSBuZXcgZ2xvYmFscy5IZWFkZXJzKHNvdXJjZTEgfHwge30pO1xuXHRjb25zdCBpc0hlYWRlcnNJbnN0YW5jZSA9IHNvdXJjZTIgaW5zdGFuY2VvZiBnbG9iYWxzLkhlYWRlcnM7XG5cdGNvbnN0IHNvdXJjZSA9IG5ldyBnbG9iYWxzLkhlYWRlcnMoc291cmNlMiB8fCB7fSk7XG5cblx0Zm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2Ygc291cmNlKSB7XG5cdFx0aWYgKChpc0hlYWRlcnNJbnN0YW5jZSAmJiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcpIHx8IHZhbHVlID09PSB1bmRlZmluZWQpIHtcblx0XHRcdHJlc3VsdC5kZWxldGUoa2V5KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmVzdWx0LnNldChrZXksIHZhbHVlKTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gcmVzdWx0O1xufTtcblxuY29uc3QgZGVlcE1lcmdlID0gKC4uLnNvdXJjZXMpID0+IHtcblx0bGV0IHJldHVyblZhbHVlID0ge307XG5cdGxldCBoZWFkZXJzID0ge307XG5cblx0Zm9yIChjb25zdCBzb3VyY2Ugb2Ygc291cmNlcykge1xuXHRcdGlmIChBcnJheS5pc0FycmF5KHNvdXJjZSkpIHtcblx0XHRcdGlmICghKEFycmF5LmlzQXJyYXkocmV0dXJuVmFsdWUpKSkge1xuXHRcdFx0XHRyZXR1cm5WYWx1ZSA9IFtdO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm5WYWx1ZSA9IFsuLi5yZXR1cm5WYWx1ZSwgLi4uc291cmNlXTtcblx0XHR9IGVsc2UgaWYgKGlzT2JqZWN0KHNvdXJjZSkpIHtcblx0XHRcdGZvciAobGV0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhzb3VyY2UpKSB7XG5cdFx0XHRcdGlmIChpc09iamVjdCh2YWx1ZSkgJiYgUmVmbGVjdC5oYXMocmV0dXJuVmFsdWUsIGtleSkpIHtcblx0XHRcdFx0XHR2YWx1ZSA9IGRlZXBNZXJnZShyZXR1cm5WYWx1ZVtrZXldLCB2YWx1ZSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm5WYWx1ZSA9IHsuLi5yZXR1cm5WYWx1ZSwgW2tleV06IHZhbHVlfTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGlzT2JqZWN0KHNvdXJjZS5oZWFkZXJzKSkge1xuXHRcdFx0XHRoZWFkZXJzID0gbWVyZ2VIZWFkZXJzKGhlYWRlcnMsIHNvdXJjZS5oZWFkZXJzKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm5WYWx1ZS5oZWFkZXJzID0gaGVhZGVycztcblx0fVxuXG5cdHJldHVybiByZXR1cm5WYWx1ZTtcbn07XG5cbmNvbnN0IHJlcXVlc3RNZXRob2RzID0gW1xuXHQnZ2V0Jyxcblx0J3Bvc3QnLFxuXHQncHV0Jyxcblx0J3BhdGNoJyxcblx0J2hlYWQnLFxuXHQnZGVsZXRlJ1xuXTtcblxuY29uc3QgcmVzcG9uc2VUeXBlcyA9IHtcblx0anNvbjogJ2FwcGxpY2F0aW9uL2pzb24nLFxuXHR0ZXh0OiAndGV4dC8qJyxcblx0Zm9ybURhdGE6ICdtdWx0aXBhcnQvZm9ybS1kYXRhJyxcblx0YXJyYXlCdWZmZXI6ICcqLyonLFxuXHRibG9iOiAnKi8qJ1xufTtcblxuY29uc3QgcmV0cnlNZXRob2RzID0gW1xuXHQnZ2V0Jyxcblx0J3B1dCcsXG5cdCdoZWFkJyxcblx0J2RlbGV0ZScsXG5cdCdvcHRpb25zJyxcblx0J3RyYWNlJ1xuXTtcblxuY29uc3QgcmV0cnlTdGF0dXNDb2RlcyA9IFtcblx0NDA4LFxuXHQ0MTMsXG5cdDQyOSxcblx0NTAwLFxuXHQ1MDIsXG5cdDUwMyxcblx0NTA0XG5dO1xuXG5jb25zdCByZXRyeUFmdGVyU3RhdHVzQ29kZXMgPSBbXG5cdDQxMyxcblx0NDI5LFxuXHQ1MDNcbl07XG5cbmNvbnN0IHN0b3AgPSBTeW1ib2woJ3N0b3AnKTtcblxuY2xhc3MgSFRUUEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuXHRjb25zdHJ1Y3RvcihyZXNwb25zZSkge1xuXHRcdC8vIFNldCB0aGUgbWVzc2FnZSB0byB0aGUgc3RhdHVzIHRleHQsIHN1Y2ggYXMgVW5hdXRob3JpemVkLFxuXHRcdC8vIHdpdGggc29tZSBmYWxsYmFja3MuIFRoaXMgbWVzc2FnZSBzaG91bGQgbmV2ZXIgYmUgdW5kZWZpbmVkLlxuXHRcdHN1cGVyKFxuXHRcdFx0cmVzcG9uc2Uuc3RhdHVzVGV4dCB8fFxuXHRcdFx0U3RyaW5nKFxuXHRcdFx0XHQocmVzcG9uc2Uuc3RhdHVzID09PSAwIHx8IHJlc3BvbnNlLnN0YXR1cykgP1xuXHRcdFx0XHRcdHJlc3BvbnNlLnN0YXR1cyA6ICdVbmtub3duIHJlc3BvbnNlIGVycm9yJ1xuXHRcdFx0KVxuXHRcdCk7XG5cdFx0dGhpcy5uYW1lID0gJ0hUVFBFcnJvcic7XG5cdFx0dGhpcy5yZXNwb25zZSA9IHJlc3BvbnNlO1xuXHR9XG59XG5cbmNsYXNzIFRpbWVvdXRFcnJvciBleHRlbmRzIEVycm9yIHtcblx0Y29uc3RydWN0b3IocmVxdWVzdCkge1xuXHRcdHN1cGVyKCdSZXF1ZXN0IHRpbWVkIG91dCcpO1xuXHRcdHRoaXMubmFtZSA9ICdUaW1lb3V0RXJyb3InO1xuXHRcdHRoaXMucmVxdWVzdCA9IHJlcXVlc3Q7XG5cdH1cbn1cblxuY29uc3QgZGVsYXkgPSBtcyA9PiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgbXMpKTtcblxuLy8gYFByb21pc2UucmFjZSgpYCB3b3JrYXJvdW5kICgjOTEpXG5jb25zdCB0aW1lb3V0ID0gKHJlcXVlc3QsIGFib3J0Q29udHJvbGxlciwgb3B0aW9ucykgPT5cblx0bmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuXHRcdGNvbnN0IHRpbWVvdXRJRCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuXHRcdFx0aWYgKGFib3J0Q29udHJvbGxlcikge1xuXHRcdFx0XHRhYm9ydENvbnRyb2xsZXIuYWJvcnQoKTtcblx0XHRcdH1cblxuXHRcdFx0cmVqZWN0KG5ldyBUaW1lb3V0RXJyb3IocmVxdWVzdCkpO1xuXHRcdH0sIG9wdGlvbnMudGltZW91dCk7XG5cblx0XHQvKiBlc2xpbnQtZGlzYWJsZSBwcm9taXNlL3ByZWZlci1hd2FpdC10by10aGVuICovXG5cdFx0b3B0aW9ucy5mZXRjaChyZXF1ZXN0KVxuXHRcdFx0LnRoZW4ocmVzb2x2ZSlcblx0XHRcdC5jYXRjaChyZWplY3QpXG5cdFx0XHQudGhlbigoKSA9PiB7XG5cdFx0XHRcdGNsZWFyVGltZW91dCh0aW1lb3V0SUQpO1xuXHRcdFx0fSk7XG5cdFx0LyogZXNsaW50LWVuYWJsZSBwcm9taXNlL3ByZWZlci1hd2FpdC10by10aGVuICovXG5cdH0pO1xuXG5jb25zdCBub3JtYWxpemVSZXF1ZXN0TWV0aG9kID0gaW5wdXQgPT4gcmVxdWVzdE1ldGhvZHMuaW5jbHVkZXMoaW5wdXQpID8gaW5wdXQudG9VcHBlckNhc2UoKSA6IGlucHV0O1xuXG5jb25zdCBkZWZhdWx0UmV0cnlPcHRpb25zID0ge1xuXHRsaW1pdDogMixcblx0bWV0aG9kczogcmV0cnlNZXRob2RzLFxuXHRzdGF0dXNDb2RlczogcmV0cnlTdGF0dXNDb2Rlcyxcblx0YWZ0ZXJTdGF0dXNDb2RlczogcmV0cnlBZnRlclN0YXR1c0NvZGVzXG59O1xuXG5jb25zdCBub3JtYWxpemVSZXRyeU9wdGlvbnMgPSAocmV0cnkgPSB7fSkgPT4ge1xuXHRpZiAodHlwZW9mIHJldHJ5ID09PSAnbnVtYmVyJykge1xuXHRcdHJldHVybiB7XG5cdFx0XHQuLi5kZWZhdWx0UmV0cnlPcHRpb25zLFxuXHRcdFx0bGltaXQ6IHJldHJ5XG5cdFx0fTtcblx0fVxuXG5cdGlmIChyZXRyeS5tZXRob2RzICYmICFBcnJheS5pc0FycmF5KHJldHJ5Lm1ldGhvZHMpKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCdyZXRyeS5tZXRob2RzIG11c3QgYmUgYW4gYXJyYXknKTtcblx0fVxuXG5cdGlmIChyZXRyeS5zdGF0dXNDb2RlcyAmJiAhQXJyYXkuaXNBcnJheShyZXRyeS5zdGF0dXNDb2RlcykpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ3JldHJ5LnN0YXR1c0NvZGVzIG11c3QgYmUgYW4gYXJyYXknKTtcblx0fVxuXG5cdHJldHVybiB7XG5cdFx0Li4uZGVmYXVsdFJldHJ5T3B0aW9ucyxcblx0XHQuLi5yZXRyeSxcblx0XHRhZnRlclN0YXR1c0NvZGVzOiByZXRyeUFmdGVyU3RhdHVzQ29kZXNcblx0fTtcbn07XG5cbi8vIFRoZSBtYXhpbXVtIHZhbHVlIG9mIGEgMzJiaXQgaW50IChzZWUgaXNzdWUgIzExNylcbmNvbnN0IG1heFNhZmVUaW1lb3V0ID0gMjE0NzQ4MzY0NztcblxuY2xhc3MgS3kge1xuXHRjb25zdHJ1Y3RvcihpbnB1dCwgb3B0aW9ucyA9IHt9KSB7XG5cdFx0dGhpcy5fcmV0cnlDb3VudCA9IDA7XG5cdFx0dGhpcy5faW5wdXQgPSBpbnB1dDtcblx0XHR0aGlzLl9vcHRpb25zID0ge1xuXHRcdFx0Ly8gVE9ETzogY3JlZGVudGlhbHMgY2FuIGJlIHJlbW92ZWQgd2hlbiB0aGUgc3BlYyBjaGFuZ2UgaXMgaW1wbGVtZW50ZWQgaW4gYWxsIGJyb3dzZXJzLiBDb250ZXh0OiBodHRwczovL3d3dy5jaHJvbWVzdGF0dXMuY29tL2ZlYXR1cmUvNDUzOTQ3MzMxMjM1MDIwOFxuXHRcdFx0Y3JlZGVudGlhbHM6IHRoaXMuX2lucHV0LmNyZWRlbnRpYWxzIHx8ICdzYW1lLW9yaWdpbicsXG5cdFx0XHQuLi5vcHRpb25zLFxuXHRcdFx0aGVhZGVyczogbWVyZ2VIZWFkZXJzKHRoaXMuX2lucHV0LmhlYWRlcnMsIG9wdGlvbnMuaGVhZGVycyksXG5cdFx0XHRob29rczogZGVlcE1lcmdlKHtcblx0XHRcdFx0YmVmb3JlUmVxdWVzdDogW10sXG5cdFx0XHRcdGJlZm9yZVJldHJ5OiBbXSxcblx0XHRcdFx0YWZ0ZXJSZXNwb25zZTogW11cblx0XHRcdH0sIG9wdGlvbnMuaG9va3MpLFxuXHRcdFx0bWV0aG9kOiBub3JtYWxpemVSZXF1ZXN0TWV0aG9kKG9wdGlvbnMubWV0aG9kIHx8IHRoaXMuX2lucHV0Lm1ldGhvZCksXG5cdFx0XHRwcmVmaXhVcmw6IFN0cmluZyhvcHRpb25zLnByZWZpeFVybCB8fCAnJyksXG5cdFx0XHRyZXRyeTogbm9ybWFsaXplUmV0cnlPcHRpb25zKG9wdGlvbnMucmV0cnkpLFxuXHRcdFx0dGhyb3dIdHRwRXJyb3JzOiBvcHRpb25zLnRocm93SHR0cEVycm9ycyAhPT0gZmFsc2UsXG5cdFx0XHR0aW1lb3V0OiB0eXBlb2Ygb3B0aW9ucy50aW1lb3V0ID09PSAndW5kZWZpbmVkJyA/IDEwMDAwIDogb3B0aW9ucy50aW1lb3V0LFxuXHRcdFx0ZmV0Y2g6IG9wdGlvbnMuZmV0Y2ggfHwgZ2xvYmFscy5mZXRjaFxuXHRcdH07XG5cblx0XHRpZiAodHlwZW9mIHRoaXMuX2lucHV0ICE9PSAnc3RyaW5nJyAmJiAhKHRoaXMuX2lucHV0IGluc3RhbmNlb2YgVVJMIHx8IHRoaXMuX2lucHV0IGluc3RhbmNlb2YgZ2xvYmFscy5SZXF1ZXN0KSkge1xuXHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignYGlucHV0YCBtdXN0IGJlIGEgc3RyaW5nLCBVUkwsIG9yIFJlcXVlc3QnKTtcblx0XHR9XG5cblx0XHRpZiAodGhpcy5fb3B0aW9ucy5wcmVmaXhVcmwgJiYgdHlwZW9mIHRoaXMuX2lucHV0ID09PSAnc3RyaW5nJykge1xuXHRcdFx0aWYgKHRoaXMuX2lucHV0LnN0YXJ0c1dpdGgoJy8nKSkge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ2BpbnB1dGAgbXVzdCBub3QgYmVnaW4gd2l0aCBhIHNsYXNoIHdoZW4gdXNpbmcgYHByZWZpeFVybGAnKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCF0aGlzLl9vcHRpb25zLnByZWZpeFVybC5lbmRzV2l0aCgnLycpKSB7XG5cdFx0XHRcdHRoaXMuX29wdGlvbnMucHJlZml4VXJsICs9ICcvJztcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5faW5wdXQgPSB0aGlzLl9vcHRpb25zLnByZWZpeFVybCArIHRoaXMuX2lucHV0O1xuXHRcdH1cblxuXHRcdGlmIChzdXBwb3J0c0Fib3J0Q29udHJvbGxlcikge1xuXHRcdFx0dGhpcy5hYm9ydENvbnRyb2xsZXIgPSBuZXcgZ2xvYmFscy5BYm9ydENvbnRyb2xsZXIoKTtcblx0XHRcdGlmICh0aGlzLl9vcHRpb25zLnNpZ25hbCkge1xuXHRcdFx0XHR0aGlzLl9vcHRpb25zLnNpZ25hbC5hZGRFdmVudExpc3RlbmVyKCdhYm9ydCcsICgpID0+IHtcblx0XHRcdFx0XHR0aGlzLmFib3J0Q29udHJvbGxlci5hYm9ydCgpO1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5fb3B0aW9ucy5zaWduYWwgPSB0aGlzLmFib3J0Q29udHJvbGxlci5zaWduYWw7XG5cdFx0fVxuXG5cdFx0dGhpcy5yZXF1ZXN0ID0gbmV3IGdsb2JhbHMuUmVxdWVzdCh0aGlzLl9pbnB1dCwgdGhpcy5fb3B0aW9ucyk7XG5cblx0XHRpZiAodGhpcy5fb3B0aW9ucy5zZWFyY2hQYXJhbXMpIHtcblx0XHRcdGNvbnN0IHNlYXJjaFBhcmFtcyA9ICc/JyArIG5ldyBVUkxTZWFyY2hQYXJhbXModGhpcy5fb3B0aW9ucy5zZWFyY2hQYXJhbXMpLnRvU3RyaW5nKCk7XG5cdFx0XHRjb25zdCB1cmwgPSB0aGlzLnJlcXVlc3QudXJsLnJlcGxhY2UoLyg/OlxcPy4qPyk/KD89I3wkKS8sIHNlYXJjaFBhcmFtcyk7XG5cblx0XHRcdC8vIFRvIHByb3ZpZGUgY29ycmVjdCBmb3JtIGJvdW5kYXJ5LCBDb250ZW50LVR5cGUgaGVhZGVyIHNob3VsZCBiZSBkZWxldGVkIGVhY2ggdGltZSB3aGVuIG5ldyBSZXF1ZXN0IGluc3RhbnRpYXRlZCBmcm9tIGFub3RoZXIgb25lXG5cdFx0XHRpZiAoKChzdXBwb3J0c0Zvcm1EYXRhICYmIHRoaXMuX29wdGlvbnMuYm9keSBpbnN0YW5jZW9mIGdsb2JhbHMuRm9ybURhdGEpIHx8IHRoaXMuX29wdGlvbnMuYm9keSBpbnN0YW5jZW9mIFVSTFNlYXJjaFBhcmFtcykgJiYgISh0aGlzLl9vcHRpb25zLmhlYWRlcnMgJiYgdGhpcy5fb3B0aW9ucy5oZWFkZXJzWydjb250ZW50LXR5cGUnXSkpIHtcblx0XHRcdFx0dGhpcy5yZXF1ZXN0LmhlYWRlcnMuZGVsZXRlKCdjb250ZW50LXR5cGUnKTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5yZXF1ZXN0ID0gbmV3IGdsb2JhbHMuUmVxdWVzdChuZXcgZ2xvYmFscy5SZXF1ZXN0KHVybCwgdGhpcy5yZXF1ZXN0KSwgdGhpcy5fb3B0aW9ucyk7XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMuX29wdGlvbnMuanNvbiAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHR0aGlzLl9vcHRpb25zLmJvZHkgPSBKU09OLnN0cmluZ2lmeSh0aGlzLl9vcHRpb25zLmpzb24pO1xuXHRcdFx0dGhpcy5yZXF1ZXN0LmhlYWRlcnMuc2V0KCdjb250ZW50LXR5cGUnLCAnYXBwbGljYXRpb24vanNvbicpO1xuXHRcdFx0dGhpcy5yZXF1ZXN0ID0gbmV3IGdsb2JhbHMuUmVxdWVzdCh0aGlzLnJlcXVlc3QsIHtib2R5OiB0aGlzLl9vcHRpb25zLmJvZHl9KTtcblx0XHR9XG5cblx0XHRjb25zdCBmbiA9IGFzeW5jICgpID0+IHtcblx0XHRcdGlmICh0aGlzLl9vcHRpb25zLnRpbWVvdXQgPiBtYXhTYWZlVGltZW91dCkge1xuXHRcdFx0XHR0aHJvdyBuZXcgUmFuZ2VFcnJvcihgVGhlIFxcYHRpbWVvdXRcXGAgb3B0aW9uIGNhbm5vdCBiZSBncmVhdGVyIHRoYW4gJHttYXhTYWZlVGltZW91dH1gKTtcblx0XHRcdH1cblxuXHRcdFx0YXdhaXQgZGVsYXkoMSk7XG5cdFx0XHRsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLl9mZXRjaCgpO1xuXG5cdFx0XHRmb3IgKGNvbnN0IGhvb2sgb2YgdGhpcy5fb3B0aW9ucy5ob29rcy5hZnRlclJlc3BvbnNlKSB7XG5cdFx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1hd2FpdC1pbi1sb29wXG5cdFx0XHRcdGNvbnN0IG1vZGlmaWVkUmVzcG9uc2UgPSBhd2FpdCBob29rKFxuXHRcdFx0XHRcdHRoaXMucmVxdWVzdCxcblx0XHRcdFx0XHR0aGlzLl9vcHRpb25zLFxuXHRcdFx0XHRcdHRoaXMuX2RlY29yYXRlUmVzcG9uc2UocmVzcG9uc2UuY2xvbmUoKSlcblx0XHRcdFx0KTtcblxuXHRcdFx0XHRpZiAobW9kaWZpZWRSZXNwb25zZSBpbnN0YW5jZW9mIGdsb2JhbHMuUmVzcG9uc2UpIHtcblx0XHRcdFx0XHRyZXNwb25zZSA9IG1vZGlmaWVkUmVzcG9uc2U7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0dGhpcy5fZGVjb3JhdGVSZXNwb25zZShyZXNwb25zZSk7XG5cblx0XHRcdGlmICghcmVzcG9uc2Uub2sgJiYgdGhpcy5fb3B0aW9ucy50aHJvd0h0dHBFcnJvcnMpIHtcblx0XHRcdFx0dGhyb3cgbmV3IEhUVFBFcnJvcihyZXNwb25zZSk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIGBvbkRvd25sb2FkUHJvZ3Jlc3NgIGlzIHBhc3NlZCwgaXQgdXNlcyB0aGUgc3RyZWFtIEFQSSBpbnRlcm5hbGx5XG5cdFx0XHQvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuXHRcdFx0aWYgKHRoaXMuX29wdGlvbnMub25Eb3dubG9hZFByb2dyZXNzKSB7XG5cdFx0XHRcdGlmICh0eXBlb2YgdGhpcy5fb3B0aW9ucy5vbkRvd25sb2FkUHJvZ3Jlc3MgIT09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgYG9uRG93bmxvYWRQcm9ncmVzc2Agb3B0aW9uIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCFzdXBwb3J0c1N0cmVhbXMpIHtcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1N0cmVhbXMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4geW91ciBlbnZpcm9ubWVudC4gYFJlYWRhYmxlU3RyZWFtYCBpcyBtaXNzaW5nLicpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHRoaXMuX3N0cmVhbShyZXNwb25zZS5jbG9uZSgpLCB0aGlzLl9vcHRpb25zLm9uRG93bmxvYWRQcm9ncmVzcyk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiByZXNwb25zZTtcblx0XHR9O1xuXG5cdFx0Y29uc3QgaXNSZXRyaWFibGVNZXRob2QgPSB0aGlzLl9vcHRpb25zLnJldHJ5Lm1ldGhvZHMuaW5jbHVkZXModGhpcy5yZXF1ZXN0Lm1ldGhvZC50b0xvd2VyQ2FzZSgpKTtcblx0XHRjb25zdCByZXN1bHQgPSBpc1JldHJpYWJsZU1ldGhvZCA/IHRoaXMuX3JldHJ5KGZuKSA6IGZuKCk7XG5cblx0XHRmb3IgKGNvbnN0IFt0eXBlLCBtaW1lVHlwZV0gb2YgT2JqZWN0LmVudHJpZXMocmVzcG9uc2VUeXBlcykpIHtcblx0XHRcdHJlc3VsdFt0eXBlXSA9IGFzeW5jICgpID0+IHtcblx0XHRcdFx0dGhpcy5yZXF1ZXN0LmhlYWRlcnMuc2V0KCdhY2NlcHQnLCB0aGlzLnJlcXVlc3QuaGVhZGVycy5nZXQoJ2FjY2VwdCcpIHx8IG1pbWVUeXBlKTtcblxuXHRcdFx0XHRjb25zdCByZXNwb25zZSA9IChhd2FpdCByZXN1bHQpLmNsb25lKCk7XG5cblx0XHRcdFx0aWYgKHR5cGUgPT09ICdqc29uJykge1xuXHRcdFx0XHRcdGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDIwNCkge1xuXHRcdFx0XHRcdFx0cmV0dXJuICcnO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmIChvcHRpb25zLnBhcnNlSnNvbikge1xuXHRcdFx0XHRcdFx0cmV0dXJuIG9wdGlvbnMucGFyc2VKc29uKGF3YWl0IHJlc3BvbnNlLnRleHQoKSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHJlc3BvbnNlW3R5cGVdKCk7XG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdHJldHVybiByZXN1bHQ7XG5cdH1cblxuXHRfY2FsY3VsYXRlUmV0cnlEZWxheShlcnJvcikge1xuXHRcdHRoaXMuX3JldHJ5Q291bnQrKztcblxuXHRcdGlmICh0aGlzLl9yZXRyeUNvdW50IDwgdGhpcy5fb3B0aW9ucy5yZXRyeS5saW1pdCAmJiAhKGVycm9yIGluc3RhbmNlb2YgVGltZW91dEVycm9yKSkge1xuXHRcdFx0aWYgKGVycm9yIGluc3RhbmNlb2YgSFRUUEVycm9yKSB7XG5cdFx0XHRcdGlmICghdGhpcy5fb3B0aW9ucy5yZXRyeS5zdGF0dXNDb2Rlcy5pbmNsdWRlcyhlcnJvci5yZXNwb25zZS5zdGF0dXMpKSB7XG5cdFx0XHRcdFx0cmV0dXJuIDA7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjb25zdCByZXRyeUFmdGVyID0gZXJyb3IucmVzcG9uc2UuaGVhZGVycy5nZXQoJ1JldHJ5LUFmdGVyJyk7XG5cdFx0XHRcdGlmIChyZXRyeUFmdGVyICYmIHRoaXMuX29wdGlvbnMucmV0cnkuYWZ0ZXJTdGF0dXNDb2Rlcy5pbmNsdWRlcyhlcnJvci5yZXNwb25zZS5zdGF0dXMpKSB7XG5cdFx0XHRcdFx0bGV0IGFmdGVyID0gTnVtYmVyKHJldHJ5QWZ0ZXIpO1xuXHRcdFx0XHRcdGlmIChOdW1iZXIuaXNOYU4oYWZ0ZXIpKSB7XG5cdFx0XHRcdFx0XHRhZnRlciA9IERhdGUucGFyc2UocmV0cnlBZnRlcikgLSBEYXRlLm5vdygpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRhZnRlciAqPSAxMDAwO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmICh0eXBlb2YgdGhpcy5fb3B0aW9ucy5yZXRyeS5tYXhSZXRyeUFmdGVyICE9PSAndW5kZWZpbmVkJyAmJiBhZnRlciA+IHRoaXMuX29wdGlvbnMucmV0cnkubWF4UmV0cnlBZnRlcikge1xuXHRcdFx0XHRcdFx0cmV0dXJuIDA7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cmV0dXJuIGFmdGVyO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGVycm9yLnJlc3BvbnNlLnN0YXR1cyA9PT0gNDEzKSB7XG5cdFx0XHRcdFx0cmV0dXJuIDA7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgQkFDS09GRl9GQUNUT1IgPSAwLjM7XG5cdFx0XHRyZXR1cm4gQkFDS09GRl9GQUNUT1IgKiAoMiAqKiAodGhpcy5fcmV0cnlDb3VudCAtIDEpKSAqIDEwMDA7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIDA7XG5cdH1cblxuXHRfZGVjb3JhdGVSZXNwb25zZShyZXNwb25zZSkge1xuXHRcdGlmICh0aGlzLl9vcHRpb25zLnBhcnNlSnNvbikge1xuXHRcdFx0cmVzcG9uc2UuanNvbiA9IGFzeW5jICgpID0+IHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX29wdGlvbnMucGFyc2VKc29uKGF3YWl0IHJlc3BvbnNlLnRleHQoKSk7XG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdHJldHVybiByZXNwb25zZTtcblx0fVxuXG5cdGFzeW5jIF9yZXRyeShmbikge1xuXHRcdHRyeSB7XG5cdFx0XHRyZXR1cm4gYXdhaXQgZm4oKTtcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0Y29uc3QgbXMgPSBNYXRoLm1pbih0aGlzLl9jYWxjdWxhdGVSZXRyeURlbGF5KGVycm9yKSwgbWF4U2FmZVRpbWVvdXQpO1xuXHRcdFx0aWYgKG1zICE9PSAwICYmIHRoaXMuX3JldHJ5Q291bnQgPiAwKSB7XG5cdFx0XHRcdGF3YWl0IGRlbGF5KG1zKTtcblxuXHRcdFx0XHRmb3IgKGNvbnN0IGhvb2sgb2YgdGhpcy5fb3B0aW9ucy5ob29rcy5iZWZvcmVSZXRyeSkge1xuXHRcdFx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1hd2FpdC1pbi1sb29wXG5cdFx0XHRcdFx0Y29uc3QgaG9va1Jlc3VsdCA9IGF3YWl0IGhvb2soe1xuXHRcdFx0XHRcdFx0cmVxdWVzdDogdGhpcy5yZXF1ZXN0LFxuXHRcdFx0XHRcdFx0b3B0aW9uczogdGhpcy5fb3B0aW9ucyxcblx0XHRcdFx0XHRcdGVycm9yLFxuXHRcdFx0XHRcdFx0cmV0cnlDb3VudDogdGhpcy5fcmV0cnlDb3VudFxuXHRcdFx0XHRcdH0pO1xuXG5cdFx0XHRcdFx0Ly8gSWYgYHN0b3BgIGlzIHJldHVybmVkIGZyb20gdGhlIGhvb2ssIHRoZSByZXRyeSBwcm9jZXNzIGlzIHN0b3BwZWRcblx0XHRcdFx0XHRpZiAoaG9va1Jlc3VsdCA9PT0gc3RvcCkge1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiB0aGlzLl9yZXRyeShmbik7XG5cdFx0XHR9XG5cblx0XHRcdGlmICh0aGlzLl9vcHRpb25zLnRocm93SHR0cEVycm9ycykge1xuXHRcdFx0XHR0aHJvdyBlcnJvcjtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRhc3luYyBfZmV0Y2goKSB7XG5cdFx0Zm9yIChjb25zdCBob29rIG9mIHRoaXMuX29wdGlvbnMuaG9va3MuYmVmb3JlUmVxdWVzdCkge1xuXHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWF3YWl0LWluLWxvb3Bcblx0XHRcdGNvbnN0IHJlc3VsdCA9IGF3YWl0IGhvb2sodGhpcy5yZXF1ZXN0LCB0aGlzLl9vcHRpb25zKTtcblxuXHRcdFx0aWYgKHJlc3VsdCBpbnN0YW5jZW9mIFJlcXVlc3QpIHtcblx0XHRcdFx0dGhpcy5yZXF1ZXN0ID0gcmVzdWx0O1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblxuXHRcdFx0aWYgKHJlc3VsdCBpbnN0YW5jZW9mIFJlc3BvbnNlKSB7XG5cdFx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMuX29wdGlvbnMudGltZW91dCA9PT0gZmFsc2UpIHtcblx0XHRcdHJldHVybiB0aGlzLl9vcHRpb25zLmZldGNoKHRoaXMucmVxdWVzdC5jbG9uZSgpKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGltZW91dCh0aGlzLnJlcXVlc3QuY2xvbmUoKSwgdGhpcy5hYm9ydENvbnRyb2xsZXIsIHRoaXMuX29wdGlvbnMpO1xuXHR9XG5cblx0LyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cblx0X3N0cmVhbShyZXNwb25zZSwgb25Eb3dubG9hZFByb2dyZXNzKSB7XG5cdFx0Y29uc3QgdG90YWxCeXRlcyA9IE51bWJlcihyZXNwb25zZS5oZWFkZXJzLmdldCgnY29udGVudC1sZW5ndGgnKSkgfHwgMDtcblx0XHRsZXQgdHJhbnNmZXJyZWRCeXRlcyA9IDA7XG5cblx0XHRyZXR1cm4gbmV3IGdsb2JhbHMuUmVzcG9uc2UoXG5cdFx0XHRuZXcgZ2xvYmFscy5SZWFkYWJsZVN0cmVhbSh7XG5cdFx0XHRcdHN0YXJ0KGNvbnRyb2xsZXIpIHtcblx0XHRcdFx0XHRjb25zdCByZWFkZXIgPSByZXNwb25zZS5ib2R5LmdldFJlYWRlcigpO1xuXG5cdFx0XHRcdFx0aWYgKG9uRG93bmxvYWRQcm9ncmVzcykge1xuXHRcdFx0XHRcdFx0b25Eb3dubG9hZFByb2dyZXNzKHtwZXJjZW50OiAwLCB0cmFuc2ZlcnJlZEJ5dGVzOiAwLCB0b3RhbEJ5dGVzfSwgbmV3IFVpbnQ4QXJyYXkoKSk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0YXN5bmMgZnVuY3Rpb24gcmVhZCgpIHtcblx0XHRcdFx0XHRcdGNvbnN0IHtkb25lLCB2YWx1ZX0gPSBhd2FpdCByZWFkZXIucmVhZCgpO1xuXHRcdFx0XHRcdFx0aWYgKGRvbmUpIHtcblx0XHRcdFx0XHRcdFx0Y29udHJvbGxlci5jbG9zZSgpO1xuXHRcdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGlmIChvbkRvd25sb2FkUHJvZ3Jlc3MpIHtcblx0XHRcdFx0XHRcdFx0dHJhbnNmZXJyZWRCeXRlcyArPSB2YWx1ZS5ieXRlTGVuZ3RoO1xuXHRcdFx0XHRcdFx0XHRjb25zdCBwZXJjZW50ID0gdG90YWxCeXRlcyA9PT0gMCA/IDAgOiB0cmFuc2ZlcnJlZEJ5dGVzIC8gdG90YWxCeXRlcztcblx0XHRcdFx0XHRcdFx0b25Eb3dubG9hZFByb2dyZXNzKHtwZXJjZW50LCB0cmFuc2ZlcnJlZEJ5dGVzLCB0b3RhbEJ5dGVzfSwgdmFsdWUpO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRjb250cm9sbGVyLmVucXVldWUodmFsdWUpO1xuXHRcdFx0XHRcdFx0cmVhZCgpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJlYWQoKTtcblx0XHRcdFx0fVxuXHRcdFx0fSlcblx0XHQpO1xuXHR9XG59XG5cbmNvbnN0IHZhbGlkYXRlQW5kTWVyZ2UgPSAoLi4uc291cmNlcykgPT4ge1xuXHRmb3IgKGNvbnN0IHNvdXJjZSBvZiBzb3VyY2VzKSB7XG5cdFx0aWYgKCghaXNPYmplY3Qoc291cmNlKSB8fCBBcnJheS5pc0FycmF5KHNvdXJjZSkpICYmIHR5cGVvZiBzb3VyY2UgIT09ICd1bmRlZmluZWQnKSB7XG5cdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgYG9wdGlvbnNgIGFyZ3VtZW50IG11c3QgYmUgYW4gb2JqZWN0Jyk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGRlZXBNZXJnZSh7fSwgLi4uc291cmNlcyk7XG59O1xuXG5jb25zdCBjcmVhdGVJbnN0YW5jZSA9IGRlZmF1bHRzID0+IHtcblx0Y29uc3Qga3kgPSAoaW5wdXQsIG9wdGlvbnMpID0+IG5ldyBLeShpbnB1dCwgdmFsaWRhdGVBbmRNZXJnZShkZWZhdWx0cywgb3B0aW9ucykpO1xuXG5cdGZvciAoY29uc3QgbWV0aG9kIG9mIHJlcXVlc3RNZXRob2RzKSB7XG5cdFx0a3lbbWV0aG9kXSA9IChpbnB1dCwgb3B0aW9ucykgPT4gbmV3IEt5KGlucHV0LCB2YWxpZGF0ZUFuZE1lcmdlKGRlZmF1bHRzLCBvcHRpb25zLCB7bWV0aG9kfSkpO1xuXHR9XG5cblx0a3kuSFRUUEVycm9yID0gSFRUUEVycm9yO1xuXHRreS5UaW1lb3V0RXJyb3IgPSBUaW1lb3V0RXJyb3I7XG5cdGt5LmNyZWF0ZSA9IG5ld0RlZmF1bHRzID0+IGNyZWF0ZUluc3RhbmNlKHZhbGlkYXRlQW5kTWVyZ2UobmV3RGVmYXVsdHMpKTtcblx0a3kuZXh0ZW5kID0gbmV3RGVmYXVsdHMgPT4gY3JlYXRlSW5zdGFuY2UodmFsaWRhdGVBbmRNZXJnZShkZWZhdWx0cywgbmV3RGVmYXVsdHMpKTtcblx0a3kuc3RvcCA9IHN0b3A7XG5cblx0cmV0dXJuIGt5O1xufTtcblxuZXhwb3J0IGRlZmF1bHQgY3JlYXRlSW5zdGFuY2UoKTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/ky/index.js\n");

/***/ })

})